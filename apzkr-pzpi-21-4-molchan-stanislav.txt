Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

					Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: «Моніторингова система відстеження та аналітики використання одягу та обладнання для оптимізації споживання та виробничих процесів»
                                                  
Студент гр. ПЗПІ-21-4                            __________________Молчан С.В.
	(підпис)
Керівник роботи                                      __________________доц. Лещинська І.О.
	(підпис)

Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія:                                                     __________________доц. Лещинський В.О.
	(підпис)
                                                                   __________________доц. Лещинська І.О.
	(підпис)
                                                                   __________________ст. викл. Сокорчук І.П.
	(підпис)

Харків 
2024
Аркуш Завдання

Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук Кафедра програмної інженерії 
Спеціальність 121 – Інженерія програмного забезпечення
Курс          3       Семестр                                         6                                                 _      
Навчальна дисципліна Архітектура програмного забезпечення           

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                           Молчана Станіслава Віталійовича                                    _
1. Тема проєкту: Моніторингова система відстеження та аналітики використання одягу та обладнання для оптимізації споживання та виробничих процесів.
2. Термін узгодження завдання курсової роботи «06»    березня   2024 р.
3. Термін здачі студентом закінченої «31»    травня   2024 р.
4. Вихідні дані до проєкту (роботи): Програмна система має бути унікальною і актуальною. Вона повинна бути орієнтована на масового користувача й мати можливість монетизації. Система має включати серверну частину, клієнтську частину, мобільний застосунок та застосування IoT або смарт-пристроїв. Система має забезпечувати безпеку даних та включати інструменти адміністрування.
5. Зміст пояснювальної записки (перелік питань, що належить розробити): аркуш завдання, вступ, аналіз предметної області, структура бази даних, опис створених методів отримання та обробки даних, опис виконаних інженерних рішень структури серверу, клієнтського застосунку, розумного пристрою та мобільного застосунку.
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): UML-діаграма розгортання, UML-діаграма прецедентів, UML-діаграма взаємодії, UML-діаграма діяльності, UML-діаграма компонентів, ER- діаграма, інтерфейс головної сторінки.
КАЛЕНДАРНИЙ ПЛАН
 
 
№ 
Назва етапу 
Термін виконання 
Примітка 
1 
Функціональна специфікація програмного проєкту
28.02.2024 
 Виконано
2 
Проектування програмного проєкту
20.03.2024 
 Виконано
3 
Кодування програмного проєкту
04.05.2024 
 Виконано
4 
Оформлення пояснювальної записки
29.05.2024 
 Виконано
5 
Захист курсової роботи
01.06.2024 
 
 
 
     Дата видачі завдання «   06   »        березня           2024 р.   
      
      
     Керівник             			     	                  доц. Лещинська І.О. 
                                                                            (підпис)  
      
     Завдання прийняв до виконання  
     ст. гр. ПЗПІ-21-4                                                      Молчан С.В.
                                                                                        (підпис) 
     
     
     


РЕФЕРАТ
     
     
     Пояснювальна записка до курсової роботи: с. 123, рис. 42, табл. 3, додатки 5, джерел 5.
     АНАЛІТИКА, ГАРДЕРОБ, КОЛЕКЦІЯ, ОДЯГ, ОРГАНІЗАЦІЯ, СИСТЕМА, СИСТЕМА УПРАВЛІННЯ, СТАТИСТИКА, ТЕГИ, УПРАВЛІННЯ ГАРДЕРОБОМ.
     Об'єктом дослідження виступають системи аналітики для розумного гардеробу, що дозволяють користувачам керувати своїми речами та отримувати статистику їх використання. Розглядаються сучасні проблеми, пов'язані з організацією та систематизацією одягу та аксесуарів.
     Метою курсової роботи є розробка системи, що забезпечує підвищення ефективності управління гардеробом користувачів, а саме зберігає дані про додані речі, надає можливість сортування та впорядкування збережених даних, впроваджує можливість пошуку речей, забезпечує можливість надання кожній речі нотатки та умовне сповіщення. Данні про використання одягу користувачів будуть використані компаніями, котрі виробляють одягу для покращення ефективності виробництва та аналітики.
     Методологія даної курсової роботи включає розробку комплексної системи, що підвищує ефективність управління гардеробом користувачів. Система забезпечує збереження даних про всі додані речі. Вона надає можливість додавання нових речей, сортування та впорядкування збережених даних, надає функціонал пошуку речей та забезпечує можливість надання кожній речі рейтингів та нотаток.
     Методи розробки серверної частини ґрунтуються на використанні мови програмування .NET та фреймворку ASP.NET Core. База даних реалізована з використанням MongoDB. У якості ІоТ складової системи був обраний мікрокомп'ютер Raspberry Pi Zero W з використанням мови програмування Python..Клієнтська частина створена за допомогою бібліотеки React. Для розробки мобільної частини була обрана нативна мова програмування Kotlin з використанням OneSignal для реалізації пуш-повідомлень.
     У результаті роботи було створено програмну систему для організації та управління гардеробом. Ця система включає веб-додаток, серверну частину та смарт-пристрій для зчитування RFID-міток.
     
     
     
     
     
     
     

     
     
     

ЗМІСТ


Вступ	7
1 Аналіз та концептуальне моделювання предметної області
1.1	Бізнес-вимоги	12
1.1.1	Бізнес можливості	12
1.1.2	Бізнес-цілі та критерії успіху	13
1.1.3	Потреби клієнтів або ринку	14
1.1.4	Бізнес-ризики	15
1.2	Концепція рішення	17
1.2.1	Окреслення концепції	17
  2.2.2 Головна функціональність	18
    2.2.3 Припущення та залежності	19
1.3	Рамки та обмеження проєкту	20
1.3.1	Рамки первинного випуску	20
1.3.2	Рамки наступних випусків	22
1.3.3	Обмеження та винятки	23
1.4	Бізнес-контекст	25
1.4.1	Профілі зацікавлених сторін	25
1.4.2	Пріоритети проєкту	26
1.4.3	Робоче середовище	27
2 Постановка задачі	29
3 Проектування програмного забезпечення	31
3.1	Проектування серверної частини проєкту	31
3.2	Проектування iot частини проєкту	35
3.3	Проектування клієнтської частини проєкту	38
3.4	Проектування мобільного додатка проєкту	43
4 Кодування програмного проєкту	48
4.1     Кодування серверної частини проєкту	48
      4.1.1 Реалізація методу для обрахування знижки для користувача	53
      4.1.2 Реалізація методів обробки даних для статистики	53
      4.1.3 Створення копії даних з таблиці бази даних	55
      4.1.4 Перевірка даних на правильність вводу	56
4.2 Кодування iot частини проєкту	57
      4.2.1 Реалізація алгоритму обробки даних з міток	58
4.3 Кодування клієнтської частини проєкту	60
      4.3.1  Розробка користувацького інтерфейсу	61
4.4  Кодування клієнтської частини проєкту	73
      4.4.1 Розробка користувацького інтерфейсу	74
Висновки	90
Перелік джерел інформаційних джерел	92
Додаток А	93
Додаток Б	100
Додаток В	103
Додаток Г	116
Додаток Д	123



ВСТУП
     
     
     Особистий гардероб потребує сучасних методів управління та організації одягу, оскільки традиційні способи часто виявляються неефективними та незручними, що призводить до розчарування та безладу. Люди можуть не помічати, що вже мають певний одяг у своїй колекції, що на перший погляд здається незначною проблемою, проте може призводити до непотрібного дублювання та перевантаження гардеробу. Без належного сортування речі можуть бути розкидані по всій квартирі, що ускладнює їх пошук і підтримку порядку. Відсутність можливості легко перевірити наявність певного одягу також важлива, оскільки це може призводити до марнування часу, грошей та простору, які могли б бути використані для придбання нових речей або для інших цілей.
     Для бізнес-користувачів, таких як виробники брендів, актуальною є проблема оптимізації виробництва та інвентаризації. Відсутність точної інформації про популярність товарів і тенденції споживання може призводити до нераціонального використання ресурсів і неправильного планування виробництва. Це може спричинити перевиробництво деяких моделей одягу і нестачу інших, що негативно впливає на прибутковість компанії. Крім того, відсутність можливості моніторингу та відстеження руху товарів у реальному часі ускладнює управління логістикою та запасами.
     Ці проблеми підкреслюють актуальність розробленої програмної системи для організації та керування гардеробом. Система дозволяє легко додавати речі в застосунок за допомогою введення даних або сканування штрих-коду. Зберігаючи всі речі в додатку, користувач отримує швидкий та зручний доступ до детальної інформації про кожну річ, можливість оцінювати їх, залишати коментарі та впорядковувати дані за різними критеріями. Застосунок є простим для розуміння і використання, що дозволяє людині з будь-яким рівнем досвіду швидко його освоїти.
     Для бізнес-користувачів наш застосунок забезпечує важливі функції, такі як надання детальної статистики використання одягу та аксесуарів, що дозволяє оптимізувати виробництво та інвентаризацію. Аналітичні дані допомагають виявляти популярні товари та тенденції споживання, що сприяє прийняттю обґрунтованих бізнес-рішень. Також система підтримує функції моніторингу та відстеження, що дозволяє покращити логістику та управління запасами. Однією з важливих мотивацій для використання розумного гардеробу є можливість отримання знижок від виробників брендів, що стимулює користувачів активно використовувати систему.

1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Бізнес-вимоги
     1.1.1 Бізнес можливості
     
     
     Проаналізувавши ринок, було виявили, що наразі існують різноманітні системи для управління гардеробом та спорядженням, але жодна з них не пропонує комплексного рішення, яке б включало відстеження використання за допомогою RFID датчиків, інтеграцію з мобільними додатками для надсилання сповіщень про необхідність догляду чи заміни, а також збір даних для аналізу поведінки споживачів.
     Одним із відомих конкурентів на ринку є додаток Stylebook[1]. Цей додаток дозволяє користувачам створювати цифровий каталог свого гардеробу, планувати вбрання та отримувати деякі базові статистичні дані щодо використання одягу. Однак, він має певні обмеження. Stylebook не підтримує RFID технології для автоматичного відстеження використання одягу та не надає функцій інтеграції з мобільними додатками для надсилання сповіщень або збору даних для глибшого аналізу поведінки споживачів. Наша система, завдяки своїй унікальності та гнучкості, вирішує проблему ефективного використання одягу та обладнання, забезпечуючи користувачам інструмент для покращення організації свого гардеробу або інвентарю та брендам – цінні дані для оптимізації виробництва.
     Система, завдяки своїй унікальності та гнучкості, вирішує проблему ефективного використання одягу та обладнання, забезпечуючи користувачам інструмент для покращення організації свого гардеробу або інвентарю та брендам – цінні дані для оптимізації виробництва. Щодо монетизації, то проєкт буде мати декілька джерел:
     а) Продаж або лізинг обладнання і RFID міток для індивідуального використання у гардеробах, спортзалах, магазинах одягу та інших потенційних місцях застосування.
     б) Платні підписки для користувачів та бізнесів на програмне забезпечення системи, що включає додаткові функції аналітики, персоналізовані сповіщення та інтеграцію з іншими бізнес-процесами.
     в) Продаж даних та аналітичних звітів про поведінку споживачів та тенденції використання предметів брендам та виробникам для оптимізації їхніх асортиментів, маркетингових стратегій та виробничих ланцюгів.
     г) Партнерські програми та інтеграції з мобільними додатками, електронною комерцією та платформами соціальних медіа для крос-промоції та обміну трафіком.
     У сумі, унікальний набір функцій, висока адаптивність до потреб ринку та широкий спектр потенційних застосувань робить цю систему дуже перспективною для розвитку та монетизації, відкриваючи нові можливості для розв'язання актуальних проблем споживачів та бізнесу.
     
     
     1.1.2 Бізнес-цілі та критерії успіху

     Основні бізнес-цілі для цієї системи зосереджені на створення високоефективної, зручної та інноваційної платформи, яка задовольнятиме потреби як індивідуальних користувачів, так і бізнесів.  Основні бізнес-цілі:
     BO-1: Розробка та впровадження функціонального прототипу системи протягом перших 6 місяців.
     BO-2: Залучення первісної бази користувачів та пілотних бізнес-партнерів, включаючи не менше 5 великих роздрібних торговельних мереж та брендів одягу, до кінця першого року.

     BO-3: Досягнення позитивної динаміки в реєстрації нових користувачів із темпом зростання не менше 20% на місяць протягом другого року.
     BO-4: Розробка та реалізація крос-платформної інтеграції, що включає мобільні додатки та веб-інтерфейси для кінцевих користувачів та бізнесів до кінця першого року.
     BO-5: Генерація прибутку від продажу обладнання, підписок, аналітичних звітів та партнерських інтеграцій, з метою досягнення обсягу продажів у $1 мільйон до кінця другого року.
     Критерії успіху:
     SC-1: Забезпечення безперебійної роботи системи з доступністю на рівні 99.9%.
     SC-2: Укладення партнерських угод з не менше як 10 великими брендами та роздрібними мережами протягом першого року роботи.
     SC-3: Залучення бази користувачів системи до 50 тисяч зареєстрованих користувачів до кінця першого року.
     SC-4: Розробка та імплементація щонайменше 4 значних оновлень системи на основі відгуків користувачів та потреб ринку протягом першого року.
     SC-5: Отримання позитивних відгуків від користувачів та бізнес-партнерів, з досягненням загальної оцінки задоволення на рівні не менше 4.5 з 5 можливих за результатами опитувань задоволеності до кінця першого року.
     
     
     1.1.3 Потреби клієнтів або ринку
     
     
     Потреби клієнтів і ринку для моніторингової системи відстеження та аналітики використання одягу та обладнання є багатогранними та відображають зростаючий попит на технологічні інновації в особистому господарстві та бізнесі. Серед основних потреб:
     а) Клієнти прагнуть більшої організованості в своєму гардеробі, зокрема, відстеження частоти використання речей, щоб оптимізувати свій одяг та уникнути надмірного споживання.
     б) Бізнеси шукають детальну аналітику поведінки споживачів для кращого планування своїх колекцій, маркетингових кампаній та управління запасами.
     в) Забезпечення можливості автоматичного отримання повідомлень про необхідність догляду за предметами або заміну/ремонт, відповідно до їх використання.
     г) Споживачі все більше цікавляться зменшенням впливу на довкілля, тому прагнуть купувати менше, але краще, та використовувати речі довше і більш раціонально.
		Для того, щоб ефективно використовувати наш додаток, користувач повинен мати:
1. Пристрій з підтримкою RFID технології;
2. Стабільне інтернет-з'єднання;
3. Смартфон, планшет або комп'ютер.


     1.1.4 Бізнес-ризики


     Перш за все, є ризик технологічної застарілості. У світі швидкого розвитку технологій, існує небезпека, що запропонована система може швидко застаріти або її можуть замінити більш інноваційні рішення. Тому необхідно постійно інвестувати в дослідження та розвиток, щоб залишатися на передовій інновацій. Безперервне вдосконалення функціональності та інтеграція новітніх технологій допоможе зберігати конкурентоспроможність системи.
     Іншим значним ризиком є конфіденційність та безпека даних. Оскільки система збиратиме та аналізуватиме великі обсяги особистої інформації користувачів, існує ризик кібератак або витоків даних, що може серйозно підірвати довіру клієнтів до системи. Важливо забезпечити надійний захист даних, регулярно оновлювати системи безпеки та впроваджувати кращі практики конфіденційності. Це включає використання шифрування даних, багатофакторної аутентифікації та постійний моніторинг загроз.
     Загальноекономічні ризики, такі як рецесія або нестабільність на світових ринках, можуть обмежити споживчий попит на інноваційні рішення та вплинути на інвестиційну спроможність компанії. Під час економічного спаду, компанії можуть знизити витрати на нові технологічні рішення, що може вплинути на темпи впровадження та розвитку системи.
     Ще один важливий аспект — це регуляторні ризики. Зміни у законодавстві щодо захисту даних або використання IoT технологій можуть вимагати значних модифікацій системи для відповідності новим стандартам і нормам. Це може призвести до додаткових витрат та потреби в швидкому реагуванні на правові зміни.
     Ризик втрати ключових фахівців також не можна недооцінювати. Висококваліфіковані розробники, фахівці з безпеки та інші експерти є важливими для успішного функціонування та розвитку системи. Втрата таких співробітників може негативно вплинути на продуктивність та інноваційність компанії.
     Також слід враховувати конкурентний ризик. Інші компанії можуть випустити аналогічні або навіть більш функціональні продукти, що може знизити ринкову долю нашої системи. Для мінімізації цього ризику необхідно постійно аналізувати конкурентів та адаптувати стратегії розвитку.
     
     Нарешті, важливо враховувати ризики пов'язані з користувацьким досвідом. Якщо система виявиться складною у використанні або не буде відповідати очікуванням користувачів, це може призвести до негативних відгуків та зниження кількості користувачів. Для запобігання цьому необхідно проводити регулярне тестування з залученням користувачів та впроваджувати зворотній зв'язок у процесі розробки.
     Ретельне управління цими ризиками та впровадження відповідних стратегій дозволить забезпечити стійкість та успішний розвиток системи в умовах мінливого ринкового середовища.


     1.2 Концепція рішення
     1.2.1 Окреслення концепції


     SmartWardrobe Analytics – це комплексна платформа з веб-додатком та мобільним застосунком, призначена для оптимізації використання особистих предметів, таких як одяг і спеціалізоване обладнання, через інноваційну інтеграцію з RFID технологією. Платформа дозволяє користувачам не тільки ефективно керувати своїм гардеробом, відслідковуючи використання та стан предметів одягу, але й автоматично отримувати повідомлення про необхідність догляду або заміни речей на основі їх частоти використання.
     Для бізнесів, особливо у сфері роздрібної торгівлі та виробництва одягу, SmartWardrobe Analytics відкриває можливості для отримання цінних даних про поведінку споживачів, допомагаючи оптимізувати асортимент продукції, планувати виробничі потужності та розробляти цільові маркетингові кампанії на основі реальних даних використання продуктів.
     Система також пропонує розширені можливості для персоналізації користувацького досвіду, включаючи індивідуальні рекомендації та інтеграцію з електронною комерцією, що сприяє підвищенню задоволення споживачів і збільшенню лояльності.
     
     
     2.2.2 Головна функціональність


     Базові функції системи були обрані з метою максимізувати зручність для користувачів та надати детальну аналітику для бізнесів. Функціонал системи можна розділити на декілька основних категорій. Користувач у веб клієнті буде мати такі функції:
     MF-1: Можливість зареєструватися/авторизуватися. Система має надавати можливість налаштування даних в особистому кабінеті та перегляду особистої статистики використання одягу.
     MF-2: Можливість створення колекцій одягу для зручного перегляду.
     MF-3: Можливість додавати одяг до колекцій. Редагувати одяг як інформаційну одиницю, додавати характеристики та нотатки.
     MF-4: Можливість додати тригер на певну кількість використання. У разі спрацювання тригера, є можливість налаштувати спеціальне сповіщення.
     MF-5: Отримання індивідуальних пропозицій від виробників одягу.
     У виробників одягу буде доступний такий функціонал:
     MF-6: Система надає можливість отримання статистики по використанню одягу свого бренду за сезон; статистика по частоті використання певного одягу; статистика по одягу, котрий одягається разом; статистика про середній час між покупкою одягу та його зношенням або заміною. 
     Функціонал для адміністратора:
     MF-7: Можливість робити резервні копії даних;
     MF-8: Система надає можливість додавати / редагувати / видаляти інформацію про всі сутності у системі.
     Щодо мобільного застосунку, то користувачі будуть мати такі можливості:
     MF-9: Можливість зареєструватися/авторизуватися. Система має надавати можливість налаштування даних в особистому кабінеті та перегляду особистої статистики використання одягу.
     MF-10: Можливість створення колекцій одягу для зручного перегляду.
     MF-11: Можливість додавати одяг до колекцій. Редагувати одяг як інформаційну одиницю, додавати характеристики та нотатки.
     MF-12: Можливість додати тригер на певну кількість використання. У разі спрацювання тригера, є можливість налаштувати спеціальне сповіщення.
     MF-13: Отримання індивідуальних пропозицій від виробників одягу.
     У адміністратора у мобільному додатку буде наступний функціонал:
     MF-14: Можливість керувати інформацією – адміністратор може виконувати стандартні CRUD операції.
     У виробників одягу в мобільному застосунку буде наступний функціонал:
     MF-15: Система надає можливість отримання статистики по використанню одягу свого бренду за сезон; статистика по частоті використання певного одягу; статистика по одягу, котрий одягається разом; статистика про середній час між покупкою одягу та його зношенням або заміною.
     

     2.2.3 Припущення та залежності


     Припущення:
     - Припускається, що споживачі все більше прагнуть до раціонального використання одягу та особистих предметів, що підсилює попит на інноваційні рішення для гардеробу;
     - Припускається, що бренди одягу та виробники зацікавлені в отриманні детальної інформації про поведінку споживачів та використання своїх продуктів для оптимізації асортименту та маркетингових стратегій;
     - Виходить з припущення, що розвиток технологій інтернету речей (IoT) та RFID продовжуватиме зростати, забезпечуючи технологічну основу для реалізації подібних систем.
Залежності:
     - Реалізація системи залежить від доступності надійних і доступних RFID міток та читачів, які можуть бути інтегровані з одягом та особистими предметами без значного збільшення їх вартості;
     - Ефективність системи залежить від забезпечення високої якості інтернет-з'єднання для користувачів, оскільки основні функції системи вимагають онлайн синхронізації даних;
     - Платформа покладається на готовність користувачів встановлювати RFID мітки на свій одяг та активно використовувати систему для відстеження використання своїх речей, що може потребувати зусиль із освіти та мотивації користувачів.


     1.3 Рамки та обмеження проєкту
     1.3.1 Рамки первинного випуску

     
     Система має такі початкові головні функції для випуску.
     Функції для користувача у веб-додатку:
     SIR-1: Реєстрація та авторизація користувачів;
     SIR-2: Персоналізація профілю користувача;
     SIR-3: Створення колекцій одягу;
     SIR-4: Додавання одягу та редагування інформації про нього;
     SIR-5: Налаштування сповіщень за допомогою тригерів;
     SIR-6: Отримання індивідуальних пропозицій від виробників;
     Функції для бізнес клієнтів:
     SIR-7: Доступ до статистики по сезонному використанню;
     SIR-8: Аналіз частоти використання окремих одиниць одягу;
     SIR-9: Огляд комбінацій одягу, що використовуються разом;
     SIR-10: Статистика середнього часу між покупкою та зношенням;
     Функції для адміністратора у веб-додатку:
     SIR-11: Здійснення резервного копіювання даних;
     SIR-12: CRUD операції для управління всіма сутностями системи.
     Функції для користувача у мобільного-додатку:
     SIR-13: Реєстрація та авторизація користувачів;
     SIR-14: Персоналізація профілю користувача;
     SIR-15: Створення колекцій одягу;
     SIR-16: Додавання деталей до предметів одягу;
     SIR-17: Налаштування сповіщень за допомогою тригерів;
     SIR-18: Отримання індивідуальних пропозицій від виробників;
     Функції для бізнес клієнтів:
     SIR-19: Доступ до статистики по сезонному використанню;
     SIR-20: Аналіз частоти використання окремих одиниць одягу;
     SIR-21: Огляд комбінацій одягу, що використовуються разом;
     SIR-22: Статистика середнього часу між покупкою та зношенням;
     Функції для адміністратора у веб-додатку:
     SIR-23: CRUD операції для адміністратора.
     Функції для IoT:
     SIR-24: Запис використання одягу;
     SIR-25: Запис повернення одягу;


     1.3.2 Рамки наступних випусків


    Наступний реліз буде зосереджений на вдосконаленні існуючих функцій та впровадженні кількох ключових покращень для підвищення рівня задоволеності та залученості користувачів. Розширені функції, які планується реалізувати:
    SSR-1: Інтеграція з існуючими соціальними мережами. Користувачі матимуть можливість легко ділитися своїм гардеробом, улюбленими образами та новими придбаннями на популярних платформах соціальних мереж, таких як Facebook, Instagram та Twitter. Це сприятиме залученню спільноти, дозволить отримувати зворотній зв'язок від друзів та створювати дискусії навколо модних тенденцій.
    SSR-2: Додавання нових способів оплати. Планується розширити кількість доступних методів оплати для користувачів, включаючи підтримку цифрових гаманців, таких як Apple Pay та Google Wallet, а також криптовалют. Це забезпечить зручність та гнучкість у проведенні фінансових транзакцій для різних категорій користувачів.
    SSR-3: Інтеграція штучного інтелекту для модних порад. Впровадження алгоритмів штучного інтелекту, які аналізуватимуть стиль користувача, його вподобання та поточні модні тенденції, надаючи персоналізовані рекомендації щодо вибору одягу та аксесуарів. Це допоможе користувачам створювати стильні та актуальні образи, економлячи час та зусилля на підбір одягу.
    
    SSR-4: Розширення аналітичних функцій для бізнес-користувачів. Наша система буде надавати детальну статистику використання одягу та аксесуарів, що дозволить виробникам брендів оптимізувати процеси виробництва та інвентаризації. Аналітичні дані допоможуть виявляти популярні товари та тенденції споживання, що сприятиме прийняттю обґрунтованих бізнес-рішень.
    SSR-5: Покращення інтерфейсу користувача. Приділятиметься увага удосконаленню інтерфейсу для покращення зручності та інтуїтивності використання системи. Це включає оптимізацію навігації, впровадження більш зрозумілих та доступних функцій, а також адаптацію інтерфейсу для різних пристроїв.
    SSR-6: Розширена підтримка багатомовності та інтернаціоналізації. Для задоволення потреб різноманітної бази користувачів, буде забезпечена підтримка кількох мов та варіанти локалізації, щоб користувачі з усього світу могли взаємодіяти з продуктом на своїй рідній мові та в своєму культурному контексті.
    Загалом, ці нововведення сприятимуть підвищенню рівня задоволеності користувачів, розширенню функціональності системи та забезпеченню її конкурентоспроможності на ринку.
     
     
     1.3.3 Обмеження та винятки


    Обрана тематика має широкий спектр можливостей щодо полегшення використання додатку. Проте існують певні функції та характеристики, які могли б бути корисними для деяких користувачів, але не будуть реалізовані в початковій версії додатку. Це обмеження зумовлені необхідністю зосередження на основних функціональних можливостях, обмеженнями ресурсів та стратегічними міркуваннями. Нижче наведено основні обмеження та винятки:
    
    LE-1: Додавання картинок. Хоча додавання зображень одягу могло б покращити візуалізацію гардеробу, ця функція не буде включена в початкову версію додатку. Користувачі зможуть додавати текстові описи для кожної речі, але можливість прикріплення фотографій буде розглядатися для майбутніх релізів.
    LE-2: Звукові повідомлення від IoT. Незважаючи на те, що інтеграція звукових повідомлень від IoT пристроїв може бути корисною для нагадувань та сповіщень, ця функція не планується в першій версії системи. Основна увага буде приділена текстовим та пуш-повідомленням.
    LE-3: Обмежена кількість мов. Проєкт буде підтримувати дві головні мови - англійську та українську. Інші мови не будуть доступні в початковому релізі, проте планується розширення мовної підтримки у майбутніх версіях залежно від попиту користувачів. 
    LE-4: Читання QR-кодів та сканування штрих-кодів. Система не буде підтримувати функцію зчитування QR-кодів для додавання одягу в гардероб. Натомість, основним методом введення даних буде ручний ввід
    LE-5: Інтеграція з системами електронної комерції. Початкова версія додатку не включатиме інтеграцію з платформами електронної комерції для автоматичного оновлення наявності одягу в гардеробі після покупок. Це може бути розглянуто для майбутніх релізів.
    LE-6: Функції соціальних мереж. Хоча інтеграція з соціальними мережами запланована для майбутніх версій, початкова версія не включатиме можливість ділитися своїм гардеробом або образами на платформах соціальних мереж.
    Ці обмеження та винятки ґрунтуються на пріоритетах розробки, обмеженнях ресурсів та стратегічних міркуваннях. Хоча ці функції можуть бути розглянуті для майбутніх випусків на основі відгуків користувачів і ринкового попиту, вони не є частиною початкової версії продукту.
    
1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін
    
    
     Таблиця 1.2 – Профілі зацікавлених сторін


Зацікавлена сторона
Головна ціль

Ставлення

Головні інтереси

Обмеження
Виробники речей
Оптимізація бізнесу
Розглядаю систему, як спосіб збору великої кількості даних для використання їх у оптимізації процесів
Отримання статистики, збільшити прибуток
Повинен укласти угоду та підписатися на сервіс
Користувачі
Ефективно використовувати одяг
Ставлення позитивне, допоки продукт працює стабільно
Ефективно використовувати одяг, слідкувати за станом одягу
Ціна підключення системи: 200$(залежить від розміру залу та кількості обладнання)
Власник компанії
Заробити 1M$
Розглядає продукт як шлях до 1M$
Отримати продукт, котрий краще конкурентів та буде потрібним
Максимальний бюджет 50 тисяч доларів
Розробники
Розробити якісний застосунок
Дуже позитивне, оскільки від успішності проєкту залежить заробітна плата
Щоб платформа працювала стабільно
Немає бюджету на платні курси або додаткову підготовку
     1.4.2 Пріоритети проєкту
     
     
     Таблиця 1.3 – Пріоритети проєкту

Показник
Виконання
(етапи)

Обмеження
(граничні обмеження)

Ступінь свободи (допустимий діапазон)
План робіт
Випуск 1.0 до 14.12.2023
Розробка серверної частини до 20.04.2024
Розробка веб додатку 04.05.2024
Розробка мобільного додатку 18.05.2024
Розробка програмного забезпечення для ІоТ до 01.06.2023
Потрібно обов’язково вкластися у зазначені терміни
Функціональність
Розробка всього зазначеного функціоналу з випуску 1.0 у серверній частині, веб частині, мобільній частині та ІоТ
Розробка до випуску 1.0
Усі функції найвищого пріоритету мають бути розроблені у випуску 1.0
Якість 
Тестування функцій та виправлення помилок
Тестування та виправлення мають бути завершенні до випуску 1.0
Треба досягти мінімальної кількості багів у випуску 1.0
Персонал
Над проєктом працює один розробник
Лише один розробник має працювати над проєктом 
Не допускається залучення додаткових розробників


		Кінець таблиці 1.3

Показник
Виконання
(етапи)

Обмеження
(граничні обмеження)

Ступінь свободи (допустимий діапазон)
Ціна
Є чітко визначений бюджет
Обмежений бюджет
Перевищення бюджету допустимо лише на 5-7%
    
    
     1.4.3 Робоче середовище
    
    
    Серверна частина буде реалізована за допомогою .NET та Entity Framework (EF), оскільки я вже мав досвід з цим середовищем і воно є досить надійним та популярним. Використання .NET та EF забезпечує високу продуктивність, безпеку та можливість масштабування додатку. У якості інтегрованого середовища розробки (IDE) буде використовуватися продукт від компанії JetBrains, а саме Rider, який забезпечує ефективне та зручне написання коду, а також інтеграцію з різними системами контролю версій та інструментами розробки. Як базу даних буде використано MongoDB, яка забезпечує гнучкість та високу продуктивність для зберігання даних.
    Щодо веб-додатка, то він буде створений за допомогою React TypeScript (ReactTS), HTML та CSS. React - це ефективна бібліотека для створення користувацьких інтерфейсів, яка завдяки своїй компонентній архітектурі дозволяє створювати швидкі та масштабовані веб-застосунки. Використання TypeScript додасть статичну типізацію, що підвищить надійність та читабельність коду. Код для веб-частини буде написано у Visual Studio Code, який є популярним редактором коду з потужною екосистемою плагінів та розширень.
    Мобільна складова буде реалізована за допомогою мови програмування Kotlin, яка зарекомендувала себе як сучасна, безпечна та ефективна мова для розробки під Android. Використання Kotlin дозволяє скористатися великою кількістю бібліотек та фреймворків, що значно спрощує та прискорює процес розробки мобільного додатку. Тестування буде проходити як на емуляторі, за допомогою Android Studio, так і через USB-налагодження на реальних пристроях, що забезпечить всебічне тестування функціоналу. Для реалізації пуш-сповіщень буде підключено сервіс OneSignal, який забезпечує надійну та ефективну доставку повідомлень користувачам.
    Однією з головних переваг нашої системи є “відцифрування” речей, для чого будуть використані датчики RFID та мікрокомп'ютер Raspberry Pi Zero W. Код для роботи з Raspberry Pi буде написано в PyCharm на мові програмування Python. Для розробки взаємодії IoT з серверною частиною будуть використані такі бібліотеки, як Requests та Adafruit CircuitPython PN532, що забезпечить надійну передачу даних та управління пристроями через мережу.
    
    
2 ПОСТАНОВКА ЗАДАЧІ
     
     
     Програмна система для організації гардеробу та аналітики використання одягу Smart Wardrobe Analytics повинна підтримувати наступний функціонал:
      * Реєстрація, вхід та вихід з системи. Забезпечення процесу створення облікового запису новими користувачами шляхом введення основної інформації (ім'я, прізвище, номер телефону, електронна пошта, пароль). Можливість входу в систему для вже зареєстрованих користувачів з використанням електронної пошти та пароля.
      * Користувацький профіль. Надання користувачам можливості редагувати та переглядати свою особисту інформацію, таку як: ім’я, електронна пошта та пароль.
      * Перегляд, створення, редагування та видалення нових колекцій для одягу. Функціонал для створення та редагування відбувається використовує ручний ввід інформації у систему.
      * Пуш-сповіщення. Надання можливості створення тригера для предмета, після спрацювання якого, має приходити пуш-сповіщення на мобільному пристрої.
      * Бонусна система. Надання можливості отримувати бонуси користувачам, в залежності від того, який бренд одягу вони використовують.
      * Перегляд, створення, редагування та видалення інформації про предмет. Надання детальної інформації про предмет, включаючи назву та нотатки. Детальна інформація має надавати статистику використання предмета та можливість змінити мітку на предметі.  Функціонал для створення та редагування відбувається використовує ручний ввід інформації у систему.
      * Адміністративний функціонал. Можливість перегляду даних користувачів, зміни ролей, блокування та розблокування  та видалення користувацьких профілів з системи. Надання можливості переглядати інформацію з усіх доступних таблиць в системі та створювати, редагувати та видаляти їх рядки. У адміністратора має бути можливість створення резервних копій таблиць.
      * Підтримка англійської та української мови. Можливість вибору мови для користувачів.



3 ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
2 
3 
3.1 Проектування серверної частини проєкту

     Перед розробкою серверної частини, треба чітко описати всі сутності, котрі будуть необхідні для реалізації визначеного функціоналу. Для цього можна розробити ER-модель даних, завдяки якій можна візуалізувати всі сутності та зв’язки між ними. Після визначення всіх необхідних сутностей, була створена ER-модель даних(див. рис. Б.1 у додатку Б).
     Модель даних включає в себе наступні сутності та поля для них:
     а) користувач:
1) користувач_id;
2) ім’я;
3) прізвище;
4) електронна_пошта;
5) ролі;
6) пароль;
7) телефон;
8) місто;
9) країна
     б) роль: 
1) роль_id;
2) назва;
     в) токен_оновлння: 
1) токен_id;
2) токен;
3) дата_кінця;
     г) пропозиція: 
1) пропозиція_id;
2) знижка;
     д) бренд: 
1) бренд_id;
2) назва;
3) оцінка;
     е) умови_бонусів_бренду: 
1) умови_бонусів_бренду_id;
2) умовна_знижчка;
3) умовна_кількість_використань;
4) умовна_складність;
     ж) колекція: 
1) колекція_id;
2) назва;
3) опис
     з) сповіщення: 
1) сповіщення_id;
2) умовна_кількість_використань;
3) назва;
4) зміст;
     к) історія_використань: 
1) історія_використань_id;
2) статус;
3) дата;
     л) річ: 
1) річ_id;
2) назва;
3) замітки;
4) категорія;
     м) всі_використання: 
1) всі_використання_id;
2) назва_абонемента;
3) ціна;
4) кількість_відвідувань;
     н) RFID_мітка: 
1) RFID_мітка_id;
2) статус.
     Всі сутності мають поля для правильної реалізації запланованого функціоналу системи.
     Після того, як всі сутності визначені, слід перейти до визначення основних сценаріїв використання програмної системи. Для цього найкраще підходе UML діаграма прецедентів. Після аналізу функціоналу, котрий був визначений у документі Vision & Scope, була розроблена UML діаграма прецедентів(див. рис. Б.2 у додатку Б), в котрій присутні п’ять акторів, а саме: гість, користувач, бізнес користувач, адміністратор, бізнес адмністратор та ІоТ. Всі актори отримали весь раніше визначений функціонал. Гість може зареєструватися або увійти до системи. Користувач може змінювати особисту інформацію, переглядати створювати та переглядати свої колекції, додавати та видаляти речі з них. Також він має можливість переглянути особисті пропозиції від брендів та статистику його використань. 
     Бізнес користувач може додавати, редагувати та видаляти інформацію про бренд. Він має змогу формувати статистику по сезонах, топ речей по використанню за обраний час та перегляд комбінацій речей, котрі використовують користувачі.
     Адміністратор може змінювати будь-які дані в базі даних та отримувати необхідну інформацію. 
     Бізнес адміністратор може створювати резервні копії бази даних у форматі .csv.
     	Останній актор, це ІоТ пристрій і він може змінювати статус мітки та оновлювати кількість використань.
     Спілкування між сервером та клієнтською частиною буде реалізоване за допомогою REST API. Такий самий тип спілкування застосований і для мобільного додатку, і для IoT. Більш детальніше розглянути взаємодію серверної частини з іншими елементами системи можна на UML діаграмі розгортання(див. рис. 3.1).
     

Рисунок 3.1 – UML діаграма розгортання.

     Надходження даних від IoT теж буде реалізоване завдяки REST API. Для кращого розуміння взаємодії IoT з серверною частиною, була розроблена UML діаграма діяльності(див. рис. 3.2). Алгоритм має циклічний характер і головна його задача - зчитування RFID міток. Після зчитування, створюється спеціальна модель з інформацією про річ та новий статус, після чого йде відправка запита на скервер. Після отримання запиту серверною частиною, відбувається перевірка статусу. Якщо статус вказує що річ була використана, то відбувається зміна статусу мітки в базі даних після чого додається одне використання в історії використання і відбувається збереження змін в базі даних. 
     

3.2 Проектування IoT частини проєкту


     Перед розробкою програмного забезпечення, слід визначити основні сценарії використання програмної системи. Для цього найкраще підходе UML діаграма прецедентів. Після аналізу функціоналу для ІоТ, котрий був визначений у документі Vision & Scope, була розроблена UML діаграма прецедентів (див. рис. 3.2), в котрій присутні три актори, а саме: ІоТ, користувач та бізнес-адміністратор. Всі актори отримали весь раніше визначений функціонал. Бізнес-адміністратор може робити початкове налаштування IoT системи, а саме налаштовувати конфігурацію для мереж та встановлення програмного коду. 
     Пристрій ІоТ може зчитувати інформацію з мітки, та робити запити до бази даних, в залежності від контексту, а саме: додавати нову мітку, оновлювати статус мітки та оновлювати кількість використань тегу.
	Користувач може взаємодіяти з ІоТ, а саме сканувати мітки, при використанні одягу або ж обладнання.

 
Рисунок 3.2 – UML діаграма прецедентів для IoT частини.

     Тепер слід визначити, з яких фізичних компонентів складається ІоТ частина системи. Для визначення компонентів, найкраще підходить UML діаграма компонентів, тому вона була розроблена (див. рис. 3.3). На діаграмі можна бачити, що для ІоТ частини було використано мікроконтролер Raspberry Pi Zero W. За допомогою вбудованого модулю WiFi можна підключатися до мережі та взаємодіяти з хмарними сервісами через бездротову мережу. До цієї плати був під’єднаний RFID модуль, а саме PN532 котрий буде відправляти значення до головного мікроконтролера. Мікроконтролер та RFID модуль пов’язані між собою через протокол зв’язку SPI, який дозволяє передавати дані між мікроконтролером та пристроєм, використовуючи всього кілька провідників і забезпечити високу швидкість передачі даних.
     

Рисунок 3.3 – UML діаграма компонентів для IoT частини.

     Коли актори визначені та відомі компоненти ІоТ частини, треба розробити діаграму взаємодії (див. рис. Д.4 у додатку Д), котра відображає перебіг процесів у програмному забезпеченні. ІоТ частина системи складається з одного пристрою та модулем для  нього. Модуль зчитує інформацію з мітки та передає їх на обробку до мікроконтролера. Після чого йде відправка HTTP запиту до серверної частини, для отримання інформації за ідентифікатором мітки. Якщо ідентифікатор не знайдений, то буде відправлений новий HTTP запит для створення нової мітки у базі даних. Якщо ж інформація за отриманим ідентифікатором є, то буде відправлений HTTP запит на зміну статусу мітки.

      3.3 
Проектування клієнтської частини проєкту


     Після того, як всі сутності визначені, слід перейти до визначення основних сценаріїв використання програмної системи. Для цього найкраще підходе UML діаграма прецедентів. Після аналізу функціоналу, котрий був визначений у документі Vision & Scope, була розроблена UML діаграма прецедентів(див. рис. Д.2 у додатку Д), в котрій присутні п’ять акторів, а саме: гість, користувач, бізнес користувач, адміністратор, бізнес адміністратор та ІоТ. Всі актори отримали весь раніше визначений функціонал. Гість може зареєструватися або увійти до системи. Користувач може змінювати особисту інформацію, переглядати створювати та переглядати свої колекції, додавати та видаляти речі з них. Також він має можливість переглянути особисті пропозиції від брендів та статистику його використань.
     Бізнес користувач може додавати, редагувати та видаляти інформацію про бренд. Він має змогу формувати статистику по сезонах, топ речей по використанню за обраний час та перегляд комбінацій речей, котрі використовують користувачі.
     Адміністратор може змінювати будь-які дані в базі даних та отримувати необхідну інформацію.
	Бізнес адміністратор може створювати резервні копії бази даних у форматі .csv.
     Останній актор, це ІоТ пристрій і він може змінювати статус мітки та оновлювати кількість використань.
     В результаті концептуального моделювання предметної області, було розроблено дві діаграми та визначені основні сутності програмної системи. Тепер можна перейти до реалізації інженерних рішень.
     Для того, щоб детальніше розібратися з ролями користувачів у системі, було розроблено UML діаграму станів ролі користувача (див. рис. 3.4). Першим етапом, після якого усі користувачі отримують роль “Користувач”, є реєстрація. Для того, щоб користувач отримав роль “Бізнес”, йому треба укласти договір та надати докази, що бренд, котрий він представляє, дійсно його. Роль “Адміністратор”, можна отримати лише від іншого користувача, котрий вже має таку роль.
     

Рисунок 3.4 – Діаграма станів ролі користувача.

     Після того, як всі актори та функціонал для них визначені, слід розробити діаграму компонентів, котра відображає, як система розділена на компоненти і як саме ці компоненти взаємодіють між собою. На діаграмі (див. рис. 3.5) визначені компоненти клієнтської частини системи, а саме сторінок та їх взаємодія між собою.
     
     Головним компонентом виступає навігаційна панель, яка є центром додатку. За допомогою неї користувач може отримати доступ до різних функцій системи, таких як вхід, реєстрація, особистий кабінет, бонуси, статистика, колекції та бренди. Для адміністратора панель також надає важливий функціонал, зокрема перегляд користувачів та можливість резервного копіювання таблиць бази даних у форматі CVS.
     Сторінка "Колекції" відображає всі колекції користувача і включає підкомпоненти для створення, редагування та перегляду колекцій. Важливим елементом є сторінка "Предмети", яка відображає всі предмети в колекціях і містить підкомпоненти для додавання, редагування та перегляду деталей предметів. Це дозволяє користувачам ефективно керувати своїми речами та отримувати детальну інформацію про кожен предмет.
     Сторінка "Бренди" дозволяє користувачам керувати брендами, зокрема додавати нові бренди, редагувати існуючі та переглядати деталі. Компонент "Статистика" відображає різні статистичні дані, що допомагають користувачам отримувати аналітичні відомості щодо використання своїх речей.
     Бонусна система є важливою частиною додатку, що дозволяє бізнес-користувачам керувати бонусами та отримувати інформацію про їх ефективність. Адміністративна панель надає доступ до розширених функцій управління системою, включаючи експорт таблиць та перегляд детальної інформації про користувачів.

Рисунок 3.5 – Діаграма компонентів клієнтської частини системи.

     Коли компоненти визначені, можна спроектувати, як користувачі будуть використовувати веб-додаток, і для цього була розроблена діаграма діяльності користувача (див. рис. 3.6). Спочатку користувач має зареєструватися у додатку. Після реєстрації система визначає роль користувача, яка може бути Користувачем, Бізнес-користувачем або Адміністратором.
     Користувач може обирати колекцію та переглядати предмети у ній. Далі він має можливість переглядати використання предметів та за потреби переглядати бонуси.
     Бізнес-користувач може вибирати бренд, додавати бонусну систему та переглядати статистику.
     Адміністратор отримує доступ до перегляду даних користувачів та редагування даних. Він також може переглядати бонуси від брендів.
     
     Ця діаграма чітко ілюструє різні дії, які користувачі з різними ролями можуть виконувати у системі, що сприяє кращому розумінню функціоналу та взаємодії між компонентами системи.
     

Рисунок 3.6 – Діаграма компонентів клієнтської частини системи.

     В результаті концептуального моделювання предметної області, було розроблено чотири діаграми та визначені основні компоненти клієнтської частини системи.


     3.4 Проектування мобільного додатка проєкту
     
     
     Після того, як всі сутності визначені, слід перейти до визначення основних сценаріїв використання програмної системи. Для цього найкраще підходе UML діаграма прецедентів. Всі актори отримали функціонал, що був визначений у клієнтські частині, але була додана корисна функція для користувача, а саме створення пуш-сповіщення для речі.
     Для того, щоб детальніше розібратися з ролями користувачів у системі, було розроблено UML діаграму станів ролі користувача (див. рис. 3.4). Першим етапом, після якого усі користувачі отримують роль “Користувач”, є реєстрація. Для того, щоб користувач отримав роль “Бізнес”, йому треба укласти договір та надати докази, що бренд, котрий він представляє, дійсно його. Роль “Адміністратор”, можна отримати лише від іншого користувача, котрий вже має таку роль.
     Після того, як всі актори та функціонал для них визначені, слід розробити діаграму компонентів, котра відображає, як система розділена на компоненти і як саме ці компоненти взаємодіять мід собою. Нижче наведено рисунок (див. рис. 3.7), на якому визначені компоненти мобільного додатка системи, а саме сторінок та їх взаємодія між собою.
     Головним компонентом виступає навігаційна панель, яка є центром додатку. За допомогою неї користувач може отримати доступ до різних функцій системи, таких як вхід, реєстрація, вихід, особистий кабінет, бонуси, статистика, колекції та бренди. Для адміністратора панель також надає важливий функціонал, зокрема перегляд користувачів та можливість резервного копіювання таблиць бази даних у форматі CVS.
     Сторінка "Колекції" відображає всі колекції користувача і включає підкомпоненти для створення, редагування та перегляду колекцій. Важливим елементом є сторінка "Предмети", яка відображає всі предмети в колекціях і містить підкомпоненти для додавання, редагування та перегляду деталей предметів. На стоірнці з деталями предмета, користувач може змінити датчик на ньому та додати сповіщення для обраного предмету. Це дозволяє користувачам ефективно керувати своїми речами та отримувати детальну інформацію про кожен предмет.
     Сторінка "Бренди" дозволяє користувачам керувати брендами, зокрема додавати нові бренди, редагувати існуючі та переглядати деталі. Компонент "Статистика" відображає різні статистичні дані, що допомагають користувачам отримувати аналітичні інсайти щодо використання своїх речей.
     Адміністративна панель надає доступ до розширених функцій управління системою, включаючи експорт таблиць та перегляд детальної інформації про користувачів.

Рисунок 3.7 – Діаграма компонентів мобільного додатка системи.

     Коли компоненти визначені, можна спроектувати, як приблизно користувачі будуть використовувати мобільний додаток і для цього була розроблена діаграма діяльності користувача (див. рис. 3.8). Спочатку користувач має зареєструватися у додатку. Після реєстрації система визначає роль користувача, яка може бути Користувачем, Бізнес-користувачем або Адміністратором.
     Користувач може обирати колекцію та переглядати предмети у ній. Далі він має можливість переглядати використання предметів та за потреби переглядати бонуси.
     Бізнес-користувач може вибирати бренд, додавати бонусну систему та переглядати статистику.
     Адміністратор отримує доступ до перегляду даних користувачів та редагування даних. Він також може переглядати бонуси від брендів.
     Ця діаграма чітко ілюструє різні дії, які користувачі з різними ролями можуть виконувати у системі, що сприяє кращому розумінню функціоналу та взаємодії між компонентами системи.
     

Рисунок 3.8 – Діаграма діяльності мобільного додатку для нового користувача.

     В результаті концептуального моделювання предметної області мобільного додатка, було розроблено чотири діаграми та визначені основні компоненти додатка.
     
     
4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
     4.1 Кодування серверної частини проєкту
	
	
     Технології були для написання серверної частини були обрані виходячи з функціональних потреб системи та з особистого досвіду. Тому для написання серверної частини була обрана платформа .NET 8. Специфікація REST орієнтована на використання архітектурного стилю, який підкреслює використання ресурсів та їх ідентифікацію за допомогою URI. В ASP.NET Core були використані контролери, для створення RESTful веб-сервісів, які взаємодіють за принципами архітектурного стилю REST. 
     В якості бази даних була використана документно-орієнтована база даних MongoDB, оскільки вона надає гнучкість та ефективність у роботі з документами у форматі JSON-подібних об'єктів. MongoDB дозволяє легко масштабувати систему, пристосовуючись до зростання обсягу даних та забезпечуючи швидкий доступ до інформації. Серверна частина взаємодіє з базою даних завдяки Mongo Driver.
     Для забезпечення безпеки та аутентифікації користувачів у додатку використовується JWT (JSON Web Token) авторизація. Цей метод аутентифікації дозволяє створювати токени, які містять інформацію про користувача та його права доступу. Токени зберігаються на клієнтській стороні і передаються з кожним запитом до серверної частини, що дозволяє уникнути необхідності постійної перевірки даних користувача на сервері. Це забезпечує високий рівень безпеки та покращує продуктивність системи.
     Дотаток використовує чисту архітектуру. Суть архітектури полягає в тому, щоб організувати коди таким чином, щоб забезпечити високий рівень абстракції та легкість у тестуванні. Додаток має 5 шарів:
- Шар Domain, в якому зберігаються основні сутності;
- Application інтерфейси, DTOs, маппер профайли;
- Infrastructure включає в себе реалізації сервісів з бізнес логікою:
   - Persistence відповідає за доступ до бази даних та містить реалізацію репозиторіїв.
Специфікація REST API наведена в таблиці 1 нижче.
Таблиця 1 – Специфікація REST API серверної частини системи
Сутність
Метод
Посилання
Дія
Користувачі
GET
/users/all
Повернення список користувачів


/users/{id}
Повернення користувача за ідентифікатором

POST
/users/register
Реєстрація користувача


/users/login
Вхід у систему


/users/{id}/roles{roleName}
Додавання ролі користувачу


/users/token/refresh
Оновлення токена доступу для користувача

PUT
/users/update
Оновлення даних користувача

DELETE
/users/{id}/roles{roleName}
Видалення ролі користувача


/users/{id}
Видалення користувача
Колекція
GET
/collections/all
Повернення всіх колекцій


/collections
Повернення лише видимих колекцій


/collections/{id}
Повернення колекції за її ідентифікатором

POST
/collections/create/
Створення нової коелкції

     Продовження таблиці 1
     
Сутність
Метод
Посилання
Дія
Колекція
PUT
/collections/update
Оновлення даних про колекцію

DELETE
/collections/delete/
{id}
Видалення колекції
Річ
GET
/items/all/{collectionId}
Повертає всі речі колекції


/items/{id}
Повертає річ за ідентифікатором

POST
/items/create
Створює річ

PUT
/items/update
Оновлює дані про річ

DELETE
/items/delete/{id}
Видалення речі
Бренд
GET
/brands/{userId}
Повертає всі бренди, котрі створив користувач


/brand/{id}
Повертає бренд за ідентифікатором.


/brands/all
Повертає всі бренди

POST
/brands/create
Створює бренд

PUT
/brands/update
Оновлює дані про бренд

DELETE
/items/delete/{id}
Видалення бренду
     Продовження таблиці 1

Сутність
Метод
Посилання
Дія
Бонуси бренду
GET
/brandsBonuses/
{brandId}
Отримання бонусів брендів

POST
/brandsBonuses /create
Створює бонуси брендів

PUT
/brandsBonuses/
update
Оновлення даних про бонуси брендів

DELETE
/brandsBonuses/
delete/{id}
Видалення бонуси брендів
Сповіщення
GET
/notifications/{id}
Повертає сповіщення користувача

POST
/notifications/create
Створює сповіщення

PUT
/notifications /update
Оновлює сповіщення

DELETE
/notifications/delete/{id}
Видалення сповіщення
Пропрозиція
GET
/offers/{id}
Повертає пропозиції для користувача

POST
/offers/create
Створює пропозицію для користувача

PUT
/offers/update
Оновлює пропозицію для користувача

DELETE
/offers/delete/{id}
Видалення пропозиції
     
     
     Продовження таблиці 1

Сутність
Метод
Посилання
Дія
Використан-ня
GET
/usages/{Id}
Повертає кількість використання предмету, за ідентифікатором


/usages/totalUsageByBrand/{brandId}
Повертає кількість використань певного бренду

POST
/usages/create/
{userId}
Створення даних кількість використань

PUT
/usages/update/
{userId}
Оновлення дпних про кількість використань 

DELETE
/usages/delete/{id}
Видалення даних кількість використань
RFID мітка
POST
/rfid/create
Створення нової мітки

PUT
/rfid/updateStatus
Оновлення статусу мітки
Статистика
GET
/statistics/seasonal-item-usage
Повертає статистику по кількості використанб речей за сезони

GET
/statistics/combo
Повертає комбінацію речей, котрі використовує користувач

GET
/statistics/popular-items
Повертає топ речей по використанню обраного бренду



     4.1.1 Реалізація методу для обрахування знижки для користувача


     	Метод UpdateTagAndIncrementUsageAsync виконується при кожному використанні RFID тега, що представляє важливу частину бізнес-логіки системи. Основна мета цього методу - збільшити облік використання товарів і визначити можливість надання знижки користувачу на підставі системи бонусів.
     Перш за все, метод виконує оновлення статусу RFID тега та додає запис у історію використання товарів(див. рядок 10-16, розділ А.1 у додатку А). Це важливо для подальшого аналізу та статистичних обчислень. Далі метод перевіряє, чи був успішно оновлений статус тега і чи відбулось використання. Якщо так, то він збільшує загальний облік використання для конкретного товару. Це інформація може бути використана для аналізу популярності товарів та планування запасів.
     Після цього метод розраховує загальну кількість використань бренду користувачем(див. рядок 19, розділ А.1 у додатку А). Ця інформація може бути використана для визначення рівня активності та залучення клієнтів. Далі проводиться аналіз системи бонусів(див. рядок 22-31, розділ А.1 у додатку А). Якщо користувач перевищує умову бонусів для конкретного бренду, система розглядає можливість надання знижки. Це є частиною стратегії залучення та утримання клієнтів. Якщо умови виконані, знижка надається, а параметри бонусів оновлюються для майбутніх обчислень.
     Отже, цей метод не лише виконує математичні обчислення для визначення знижок, а й є важливою частиною бізнес-логіки, що сприяє оптимізації процесів та підвищенню задоволеності клієнтів.
     
     
     4.1.2 Реалізація методів обробки даних для статистики
     
     
     Програмна система приділяє дуже багато уваги до статистичних даних, що є невід’ємною частиною бізнес-логіки. Почнемо з статистики, котра ввиконує аналіз історії використання товарів з метою знаходження комбінацій, які часто використовуються користувачами. Це важлива частина бізнес-логіки, оскільки може допомогти виробникам розуміти популярні комбінації товарів та планувати асортимент. Спочатку метод GetItemCombinationsStatisticsAsync отримує всю історію використання товарів та список всіх товарів з бази даних. Потім він об'єднує ці дані за допомогою ідентифікаторів товарів та користувачів. Після цього метод групує дані за кожним користувачем. Для кожного користувача він сортує його історію використання за датою(див. рядок 6-11, розділ А.2 у додатку А).
     Далі метод перебирає історію використання кожного користувача та формує комбінації товарів, які були використані протягом певного періоду часу(див. рядок 26-49, розділ А.2 у додатку А). Кожна комбінація зберігається як список назв товарів. Якщо комбінація містить більше одного товару, вона додається до загального списку статистики комбінацій, який потім повертається як результат методу. Отже, цей метод поєднує в собі аналіз даних, виконує математичні обчислення для знаходження комбінацій товарів та їх частоти використання, а також відображає важливу частину бізнес-логіки, спрямовану на підвищення ефективності та задоволення потреб клієнтів.
     Наступний отримує статистику по топ найвикористовуваніших товарів для певного бренду протягом заданого періоду часу. Це важлива частина бізнес-логіки, оскільки допомагає виробникам отримувати інформацію про найпопулярніші продукти та адаптувати свою стратегію виробництва та маркетингу. Спочатку метод отримує історію використання товарів протягом заданого періоду часу. Далі отримує список товарів, що належать до певного бренду(див. рядок 9, розділ А.3 у додатку А). Потім обирає лише ті записи з історії використання, які стосуються товарів з цього бренду. Групує ці дані за ідентифікаторами товарів, рахуючи кількість використань кожного товару, і сортує в порядку спадання кількості використань. Нарешті, для кожного товару формує об'єкт PopularItemStatisticsDto, який містить назву товару та кількість його використань, і додає його до списку популярних товарів(див. рядок 17-24, розділ А.3 у додатку А). Після цього список повертається як результат методу.
     І останній статистичний метод призначений для отримання статистики використання речей за сезон. Це частина бізнес-логіки, оскільки дозволяє виробникам аналізувати, як їхні товари використовуються в різні сезони року, що може впливати на їх стратегію виробництва, маркетингу та постачання. Метод спочатку отримує список товарів, що належать до певного бренду. Потім він отримує всю історію використання товарів за допомогою методу. Далі метод проходиться по кожному запису історії використання і групує їх за сезонами(див. рядок 13-17, розділ А.4 у додатку А), використовуючи допоміжний метод GetSeason, який визначає сезон за датою створення запису. Після цього метод складає статистику для кожного сезону, рахуючи загальну кількість використань кожного товару в межах кожного сезону(див. рядок 29-38, розділ А.4 у додатку А).
     Нарешті, результати представлені у вигляді списку об'єктів SeasonalItemUsageStatisticsDto, які містять інформацію про кількість використань кожного товару в кожному сезоні, а також загальну кількість використань за кожний сезон.


     4.1.3 Створення копії даних з таблиці бази даних


     Метод ExportToCsv відповідає за експорт даних з вказаної колекції бази даних у формат CSV. Перш ніж створити CSV-файл, він витягує дані з вказаної колекції, використовуючи об'єкт контексту бази даних. Потім він формує CSV-файл з цими даними, використовуючи бібліотеку CsvHelper(див. рядок 7-29, розділ А.5 у додатку А). У цьому методі немає складної математичної обробки, але він виконує важливу бізнес-логіку, пов'язану з експортом даних, що може бути корисним для аналізу та обробки даних за межами програми. Такий експорт може бути корисним для звітності, обміну даними з іншими системами або для збереження архівних даних.


     4.1.4 Перевірка даних на правильність вводу


		Перевірка даних є частиною бізнес логіки, оскільки допомагає забезпечити коректність введених даних та враховує правила домену бізнес-застосування. Якщо введені дані не відповідають встановленим правилам (наприклад, формат електронної пошти або номера телефону), то виникає виключення, що може бути оброблене кодом для відповідного реагування на некоректні дані. Код для перевірки даних наведений нижче:

1 private async void ValidateEmail(string email)
2     {
3         string regex = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";
4
5        if (!Regex.IsMatch(email, regex))
6        {
7            throw new InvalidEmailException(email);
8        }
9    }
10
11    private void ValidatePhone(string phone)
12    {
13        string regex = @"^\+[0-9]{1,15}$";
14
15        if (!Regex.IsMatch(phone, regex))
16        {
17            throw new InvalidPhoneNumberException(phone);
18        }
19  }



     4.2 Кодування IoT частини проєкту
	
	
     Технології були для написання ІоТ частини були обрані виходячи з функціональних потреб системи. Оскільки було прийнято рішення використовувати  мікроконтролер Raspberry Pi Zero W, то був вибір, яку мову програмування використовувати. Після аналізу всіх технічних вимог, було прийнято рішення використовувати Python. Вибір Python був обґрунтований наявністю багатьох бібліотек для роботи з модулями та мікроконтролерами, що використовуються у системі. В якості основної бібліотеки, було використано adafruit_pn532.spi, котра надає змогу створювати взаємодіяти з RFID модулем.
     Додатково до вибору Python та бібліотеки adafruit_pn532.spi для взаємодії з RFID модулем, інженерні рішення також були зосереджені на інтеграції мікроконтролера з іншими компонентами системи через SPI (Serial Peripheral Interface). SPI був обраний через його швидкість та ефективність у використанні для коротких відстаней між пристроями, що ідеально підходить для взаємодії мікроконтролерів із периферійними модулями. SPI інтерфейс дозволяє здійснити швидку та надійну передачу даних між Raspberry Pi Zero W та RFID читачем, що є критично важливим для систем, де вимагається миттєва реакція на зчитування тегів. Використання SPI в даному контексті забезпечує низьке енергоспоживання та високу швидкість передачі, що робить його відмінним вибором для таких застосувань.
     Для інтеграції IoT компонентів з веб-сервісами була використана бібліотека requests, що дозволяє управляти статусами RFID тегів через API. Це забезпечує можливість легкої інтеграції з іншими частинами системи та зовнішніми сервісами, розширюючи функціональність системи та забезпечуючи зручність її масштабування та управління.


     4.2.1 Реалізація алгоритму обробки даних з міток


     	Головна ціль мого ІоТ, це зчитування даних з мітки, та оновлення даних на серверній частині, тому треба було реалізувати ефективний алгоритм, для обробки даних. Перш за все, йде налаштування з’єднання(див. рядок. 12-14, розділ Б.1 у додатку Б) між мікроконтролером та RFID модулем, за допомогою методів з бібліотеки adafruit_pn532.spi. Після чого, запускається цикл, котрий очікує на мітку. Після зчитування мітки, починається математична обробка ідентифікатора, за допомогою власно розробленої функції format_uid.
     Функція format_uid (див. рядок. 16, розділ Б.1 у додатку Б) відповідає за перетворення бінарного представлення UID, отриманого з RFID-мітки, в шістнадцятковий формат. Це перетворення забезпечується шляхом ітерації по кожному байту UID, розбиття його на старші та молодші ніббли (чотирибітні частини байта), які потім конвертуються у символи за допомогою ASCII кодування (див. рядок. 19-25, розділ Б.1 у додатку Б). Кожен ніббл трансформується в шістнадцятковий символ, що дозволяє представити байт у вигляді двох символів (наприклад, байт 0xAB представляється як символи 'A' та 'B'). Окрім формування текстового представлення UID, у функції відбувається розрахунок контрольної суми, яка є результатом сумування усіх байтів UID, обмеженим одним байтом (через взяття залишку від ділення суми на 256) (див. рядок. 26, розділ Б.1 у додатку Б). Результатом цих операцій є формування унікального ідентифікатора мітки у форматі, що включає контрольну суму, що дозволяє контролювати цілісність ідентифікатора при подальшій обробці. Використання такої математичної обробки на стороні клієнта дозволяє зменшити навантаження на серверну частину системи, оптимізувавши обробку даних. Це важливо в контексті систем IoT, де кожен компонент системи повинен бути оптимізований для ефективної роботи в умовах обмеженого обчислювального та енергетичного ресурсу. Функція format_uid забезпечує не тільки формування стандартного представлення UID, а й впровадження додаткової перевірки на помилки, що підвищує надійність і точність системи ідентифікації RFID.
     Після формування унікального ідентифікатора RFID-мітки за допомогою функції format_uid, код реалізує взаємодію з серверною частиною через API для управління даними RFID-міток. Перевірка наявності мітки в базі даних здійснюється через GET-запит до API (див. рядок. 39, розділ Б.1 у додатку Б), що використовує вже сформований UID для ідентифікації мітки. Якщо мітка існує (сервер повертає успішний відповідь з статусом 200 та наявними даними), код виконує PUT-запит (див. рядок. 42, розділ Б.1 у додатку Б) для оновлення статусу мітки, ініціюючи логіку оновлення на сервері, яка може включати, наприклад, зміну статусу доступу чи оновлення інших параметрів, залежно від системних вимог.
     У випадку, коли мітка не виявляється в базі даних (сервер повертає відповідь зі статусом, що не вказує на успішне знаходження), код реалізує POST-запит  для створення нового запису про мітку (див. рядок. 49, розділ Б.1 у додатку Б), передаючи UID як частину тіла запиту у форматі JSON. Це дозволяє автоматично реєструвати нові мітки в системі, що є критично важливим для динамічних систем ідентифікації, де нові мітки можуть регулярно вводитись в обіг.
     Правильна робота цього алгоритму є дуже важливою для подальшої розробки системи, оскільки саме завдяки ньому, до бази даних буде надходити актуальна інформація про використання речей, що напряму впливає на бізнес логіку системи. Для того, щоб зрозуміти краще як працю цей алгоритм, слід переглянути UML діаграму діяльності (див. рис. Д.3 у додатку Д). 


     4.3  Кодування клієнтської частини проєкту


     Технології були для написання клієнтської частини були обрані виходячи з функціональних потреб системи та з особистого досвіду. Тому для написання клієнтської частини був обраний React у поєднанні з TypeScript. Він фокусується на реактивному програмуванні для інтерфейсів користувача, не визначаючи при цьому структуру всього додатку. Об'єднання TypeScript та React виправдовується низкою суттєвих переваг, які сприяють покращенню якості розробки веб-застосунків.
     Для того, щоб забезпечити більш реактивне програмування був використаний MobX [3]. MobX у поєднанні з React TypeScript надає простий і гнучкий спосіб управління станами в додатках. Воно забезпечує реактивне та декларативне програмування, що дозволяє розробникам легко синхронізувати стан додатку з його UI, роблячи код більш зрозумілим та легшим для підтримки. MobX автоматично відстежує залежності між станом та компонентами, оптимізуючи оновлення лише тих частин UI, які потребують змін, що забезпечує високу продуктивність.
     Для роботи з датами та часом була обрана бібліотека “Moment”, котра є  однією з найпопулярніших бібліотек для роботи з датами та часом у React TypeScript проектах. Вона надає розробникам зручні функції для парсингу, перевірки, маніпуляції та форматування дат, враховуючи часові зони і локалізацію. 
     Для локалізації була обрана бібліотека “i18next”, котра є потужним інструментом для локалізації додатків, пропонуючи гнучке та ефективне управління багатомовним контентом. Вона підтримує динамічну зміну мов у реальному часі, що дозволяє користувачам легко перемикати мови без перезавантаження сторінки. i18next також спрощує роботу з перекладами, надаючи можливість організації перекладів у окремі файли чи ресурси, що робить процес локалізації більш упорядкованим і підтримуваним.
     
     
     4.3.1 Розробка користувацького інтерфейсу 

		
		Перш за все, новому користувача слід зареєструватися для того, щоб отримати повний фунціонал додатку. Для цього йому достатньо натиснути на кнопку “Register” на навігаційні панелі (див. розділ В.1 у додатку В). Після чого, відкриється сторінка (див. рис. 4.1) з полями для вводу даних. Обов’язковими полями є всі, крім номеру телефону. При вводі пошти та телефону, відбувається перевірка на правильність введення даних. Також, користувач має надати згоду на обробку його персональних даних.


Рисунок 4.1 – Сторінка для реєстрації.

		Після реєстрації користувача зустрічає сторінка (див. рис. 4.2), де відображаються всі його колекції. Користувач може шукати колекції за іменем. Також він може створити нову колекцію та відредагувати або видалити вже існуючу. Користувач може переглянути предмети в колекції, натиснувши на в
кнопку “items”

Рисунок 4.2 – Сторінка з списком колекцій користувача.

		На сторінці з предметами (див. рис. 4.3), користувач може переглянути всі предмети, котрі знаходяться в обраній колекції. На цій сторінці користувач може додати новий предмет, редагувати і переглянути детальну інформацію про предмет, натискаючи на відповідні кнопки.


Рисунок 4.3 – Сторінка з предметами у колекції.

     На сторінці з деталями предмета (див. рис. 4.4) користувач може побачити статистику по використанню предмета за кожен місяць та побачити всі його використання.

Рисунок 4.4 – Сторінка з деталями предмету.

	Після натискання на піктограму тегу на сторінці відкриється діалогове вікно, де користувач зможе обрати датчик, котрий хоче прив’язати до предмета (див. рис. 4.5).


Рисунок 4.5 – Діалогове вікно, де користувач може прив’язати тег до предмета.

     В залежності від кількості використання предметів однакового бренду, користувач отримує бонуси від цього бренду, котрі можна переглянути на окремій сторінці (див. рис. 4.6). Потрапити на цю сторінку можна натиснувши на кнопку “My Offers” у навігаційній панелі.
     

Рисунок 4.6 – Сторінка з бонусами користувача.

     Після входу в аккаунт, бізнес користувача зустрічає сторінка (див. рис. 4.7) з відображенням всіх його брендів. На цій сторінці користувач може обрати що робити з брендом: редагувати, додати або видалити.

Рисунок 4.7 – Сторінка з брендами бізнес користувача.

     Після натискання на кнопку “Bonus System”, бізнес користувач зможе побачити всі налаштовані бонусні системи для його брендів, зможе відредагувати та створити нові  (див. рис. 4.8).


Рисунок 4.8 – Сторінка з бонусними системами для брендів.

     На навігаційній панелі, бізнес користувач зможе відкрити список, де зможе обрати статистику, яку хоче отримати (див. рис. 4.9).
     
     
Рисунок 4.9 – Меню з вибором статистики.
     
	Одним з видів статистики, є комбінаційна статистика, яку можна відкрити натиснувши на кнопку “Combo Statistic”. Після натискання, користувач буде переадресований на сторінку, де відображаються комбінації одягу його брендів (див. рис. 4.10). Всі виклики для отримання статистик знаходяться в окремому класі (див. розділ В.2 у додатку В).
     

Рисунок 4.10 – Сторінка для статистики по комбінаціям.

     Натиснувши на кнопку “Top Statistic”, перед користувачем з’явиться сторінка (див. рис. 4.11), де він може обрати діапазон дат, бренд, та кількість предметів в топі. В залежності від всіх вказаних даних, буде сформована статистика по кількістю використання за певний діапазон дат (див. розділ В.3 у додатку В). Статистика включає в себе кругову та стовбчасту діаграму (див. рис. 4.12).


Рисунок 4.11 – Сторінка для отримання статистики по кількості використань за обраний період.


Рисунок 4.12 – Вигляд статистики “Top Statistic”.

     Для того щоб переглянути статистику по сезонах, користувачу достатньо обрати пункт “Seasonal Statistics”. На цій сторінці (див. рис. 4.13) він зможе обрати бренд, за яким хоче отримати статистику. Після чого, буде побудована таблиця, кругова та стовбчаста діаграма, де буде зазначена кількість використань предметів цього бренду за сезон (див. рис. 4.14).

Рисунок 4.13 – Сторінка для отримання статистики по кількості використань предметів обраного бренду за сезони.


Рисунок 4.14 – Діаграми для сезонної статистики.

     Користувач з роллю “Admin”, може блокувати користувачів, на спеціальній сторінці (див. рис. 4.15). Також він може проводити там пошук за електронною поштою та id. Адміністратор може робити копії даних, а саме копії таблиць, обравши пункт “Export Data” на навігаційні панелі. Також, адміністратор, може переглядати та редагувати будь-які дані в базі даних.


Рисунок 4.15 – Сторінка з списком користувачів.

Для всіх сутностей у системі є форми для створення та редагування (див. рис. 4.16). Вони мають однакову структуру, а саме всі поля сутності та дві кнопки.


Рисунок 4.16 – Сторінка для створення предметів.


     4.4 Кодування клієнтської частини проєкту


     Технології були для написання мобільного додатка були обрані виходячи з функціональних потреб системи та з особистого досвіду. Тому для написання мобільного додатку була обрана мова програмування Kotlin [5]. Вона є статично типізованою мовою програмування, яку можна використовувати для розробки на різних платформах, але вона найбільш відома як мова для розробки нативних Android-додатків. 
     Для роботи з мережевими запитами була обрана бібліотека Retrofit, котра є одна з найпопулярніших в Kotlin-додатках. Ця бібліотеки відома та широко використовується через свою здатність спрощувати процес здійснення HTTP-запитів. Retrofit дозволяє визначати HTTP-запити за допомогою інтерфейсів і анотацій, що спрощує читання і написання коду. Також великим плюсом є вбудовані конвертери для серіалізації і десеріалізації даних, наприклад, Gson або Moshi, дозволяють автоматично перетворювати JSON у Kotlin-об'єкти і навпаки.
	Для розробки та взаємодії з графічним інтерфейсом використовувалася бібліотека R. Бібліотека R в контексті Android розробки на Kotlin є автоматично генерованим класом, який використовується для доступу до ресурсів, таких як строки, зображення, в'ю елементи інтерфейсу користувача, і навіть елементи меню, визначені в XML-файлах вашого додатку. Ця бібліотека дозволяє розробникам легко отримувати доступ до цих ресурсів у коді програми, використовуючи ідентифікатори, що запобігає помилкам, які можуть виникнути через неправильне написання рядкових літералів. Вона робить код більш читабельним та легшим для підтримки, оскільки всі ресурси знаходяться в централізованому місці, що сприяє легкій зміні та оновленню ресурсів без необхідності переписування коду, де ці ресурси використовуються.
     Для реалізації функціональності пуш-повідомлень були використані Firebase та OneSignal [2]. Firebase забезпечує потужну платформу для зберігання даних, автентифікації користувачів та аналітики в реальному часі. OneSignal використовується для керування пуш-повідомленнями, дозволяючи легко надсилати повідомлення до користувачів додатку та відстежувати їх ефективність. Інтеграція з Firebase та OneSignal дозволяє забезпечити безперебійну взаємодію з користувачами та отримувати цінні дані для подальшого вдосконалення додатку.
     
     
     4.4.1 Розробка користувацького інтерфейсу 

		
		При першому запуску додатка, користувача зустрічає активність з входом. На ній (див. рис. 3.17) користувач може ввести свої дані, або ж зареєструватися.
		

Рисунок 4.17 – Активність для входу в аккаунт.

		На активності для реєстрації користувачу потрібно ввести всі необхідні дані, та натиснути на відповідну кнопку (див. рис. 4.18). 

Рисунок 4.18 – Активінсть для реєстрації.

		Після успішного входу у додаток, відкриється активність на якій відображені всі колекції користувача (див. рис. 4.19). Вище колекцій присутня кнопка для створення нової колекції. Біля кожної колекції присутні піктограми для редагування та видалення колекції. Також на кожній активності є кнопка для відкриття бокового меню, де є додаткові кнопки для навігації.


Рисунок 4.19 – Активінсть з списком колекцій користувача.

     Бокове меню (див. рис. 4.20) використовується для навігації у додатку, завдяки ньому корситувач може відкрити свої бонуси, перейти до колекцій, вийти з акаунту. Якщо ж користувач має роль “Business”, то на його панелі будуть додаткові кнопки для отримання статистики. А якщо користувач є адміністратором то у нього буде додактва кнопка для створення резервних копій таблиць.
     

Рисунок 4.20 – Бокове навігаційне меню.

	Після натискання на кнопку “Details” на сторінці з колекціями, буде відкрита активність з усіма предметами, котрі є в колеції (див. рис. 4.21). Піктограма “Око”,  дозволяє користувачу переглянути статистику предмета та переглянути його деталі.


Рисунок 4.21 – Активність з списком предметів в колекції

     Натиснуши на піктограму “Око” на активності для предметів, користувач перейде на сторінку (див. рис. 4.22), на котрій відображається статистика використання предмета (див. розділ Г.1 у додатку Г). Також зверху на активності є дві піктограми, для зміни тега на предметі (“Тег”) та налаштування сповіщень для предмета (“Дзвінок”).
     

Рисунок 4.22 – Активінсть з статистикою предмета.

     Після натискання на піктограму “Дзвінок” буде відкрита нова активність з списком всі сповіщень для цього предмета(див. рис. 4.23). Зверху активності є кнопка для створення сповіщення.
     

Рисунок 4.23 – Активність з сповіщеннями для предмета.

     Натиснувши на кнопку “Create Notification” на сторінці з сповіщеннями, користувача буде переправлено на активність з полями для сповіщення (див. рис. 4.24). Ця активність ідентична і для редагування, але поля будуть автоматично заповненні вже існуючими даними для обраного сповіщення.
     

Рисунок 4.24 – Активність дял створенян сповіщень.

     Для того, щоб сповіщення працювали, користувачу при першому відкритті програмного застосунку буде запропоновано дозволити відправку сповіщень (див. рис. 4.25).
     

Рисунок 4.25 – Системне діалогове вкіно для надання дозволу на відправлення сповіщень.

     Якщо користувач дозволе надсилати йому сповіщення, то взалежності від умов, котрі вкажке користувач, йому будуть надходити сповіщення після використанян рече (див. рис. 4.26). 
     
     

Рисунок 4.26 – Вигляд сповіщення.

     Для прегляду бонусів користувача, йому достатньо натиснути на кнопку “My Bonus” (див. рис. 4.27), де він зможе побачити свою знижку для брендів, котрими він користується.
     
     
Рисунок 4.27 – Вигляд активності з бонусами користувача.
     
     Якщо корситувач має роль “Business”, то після успішної авторизації в додатку, для нього буде відкрита активність з списоком його брендів (див. рис. 4.28), де він зможе створити новий бренд та редагувати або видалити вже існуючі.
     

Рисунок 4.28 – Активність для управління користувачами.

     Для бізнес-користувача доступні три види статистики, котрі можна обрати в навінаційному меню (див. рис. 4.29).


Рисунок 4.29 – Активність для управління користувачами.

     При настиканні на пункт “Combo Statistics”, користувача буде переправлено на активність де будуть відображатися комбінації предметів з його брендів (див. рис. 4.30). Також на сторінці є можливість переключити часовий формат (див. розділ Г.2 у додатку Г). Детально ознайомитися з реалізацією можна у додатку Г (див. розділ Г.3 у додатку Г).
 

Рисунок 4.30 – Активність для управління користувачами.

     При настиканні на пункт “Seasonal Statistics”, користувача буде переправлено на активність де буде відображатися статистика за брендом, котрий він має обрати (див. рис. 4.31). Статистика представленна у вигляді “Сезонної”, та показує які предмети в який сезон використовуються.

Рисунок 4.31 – Активність для управління користувачами.

     І останнім статистичним пунктом є “Popular Item Statistics” при натисканні на який, користувача буде переправлено на активність де буде відображатися статистика за брендом, проміжком часу та обраною кілкісттю предметів у рейтингу (див. рис. 4.32). Статистика показує які предмети найчастіше використовуються користувачами за певний проміжок часу, котрий вони можуть обрати.


Рисунок 4.32 – Активність для управління користувачами.

     Адміністратор має можливітсь блокувати та розблоковувати корситувачів на окремій активності (див. рис. 4.33). Для зручності пошуку корситувачів, була додана можливість пошуку за електронною поштою та за ідентифікатором.
     
     
Рисунок 4.34 – Активність для управління користувачами.

     Також адміністротор може створювати резервні копії таблиць (див. рис. 4.35). Натиснувши на відповідний пункт у навігаційному меню, буде відкрито діалогове вікно, де можна обрати, яку саме таблицю треба копіювати.
     
     
     Рисунок 4.36 – Діалогове вікно для вибору таблиці для резервного копіювання.

     Таким чином було розроблено та протестовано мобільний додаток, котрий повінсттю функціонує та є частиною системи.

ВИСНОВКИ
     
     
     Під час виконання курсового проєкту було проведено концептуальне моделювання та детальний аналіз предметної області управління гардеробом. На основі цього аналізу було розроблено комплексну програмну систему, яка підвищує ефективність управління гардеробом та надає цінні аналітичні інструменти для бізнес-користувачів.
     Розробка включила створення концептуальної моделі предметної області, що дозволило краще зрозуміти потреби користувачів і визначити основні вимоги до системи. Було здійснено проектування фізичної моделі даних та реалізацію системи з використанням сучасних технологій програмування. Зокрема, серверна частина була реалізована на платформі .NET 8 з використанням ASP.NET Core для створення RESTful веб-сервісів. База даних була реалізована на MongoDB, що забезпечує високу продуктивність та надійність зберігання даних. Для клієнтської частини використовувалася бібліотека React, а мобільний додаток розроблено на мові програмування Kotlin з використанням OneSignal для реалізації пуш-повідомлень. IoT-складова системи була розроблена з використанням мікрокомп'ютера Raspberry Pi Zero W та мови програмування Python.
     У результаті роботи була створена та протестована програмна система[6], яка надає користувачам інструменти для ефективного управління своїм гардеробом, забезпечуючи зручність доступу до інформації, організацію та зберігання даних про одяг. Система дозволяє створювати тригерні пуш-сповіщення, котрі будуть повідомляти користувачів про використання.
     Для бізнес-користувачів система надає важливі функції, такі як надання детальної статистики використання одягу та аксесуарів, що дозволяє оптимізувати виробництво та інвентаризацію. Аналітичні дані допомагають виявляти популярні товари та тенденції споживання, що сприяє прийняттю обґрунтованих бізнес-рішень. Також система підтримує функції моніторингу та відстеження, що дозволяє покращити логістику та управління запасами.
     Загалом, розроблена система Smart Wardrobe Analytics є зручним інструментом для організації гардеробу, забезпечуючи простоту та ефективність управління, а також надає бізнес-користувачам цінну аналітичну інформацію для оптимізації своїх процесів.





















ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
     
     
     1. Про Stylebook. URL: https://www.stylebookapp.com/about.html (дата звернення 18.03.24)
     2. Документація API OneSignal API. URL: https://documentation.onesignal.com/docs/onesignal-api (дата звернення 14.05.24)
     3. Документація MobX. URL: https://mobx.js.org/react-integration.html (дата звернення 03.05.24)
     4. Документація Raspberry Pi. URL: https://www.raspberrypi.com/documentation/ (дата звернення 21.04.24)
     5.  Документація Kotlin URL: https://kotlinlang.org/docs/home.html (дата звернення 15.05.24)
     6.	Функціональне тестування розробленого функціоналу для системи. URL: https://www.youtube.com/watch?v=Gg8SHwlGzmA















ДОДАТОК А
Код серверної частини
     	А.1 Код для визначення інтервалі для бронювання


1  public async Task<bool> UpdateTagAndIncrementUsageAsync(RFIDTagStatusUpdate statusUpdate, CancellationToken cancellationToken)
2      {
3          var objectId = ObjectId.Parse(statusUpdate.Id);
4          var updateSuccessful = await _rfidTagRepository.UpdateStatus(statusUpdate, cancellationToken);
5          var tag = await _rfidTagRepository.GetOneAsync(ObjectId.Parse(statusUpdate.Id), cancellationToken);
6          var item = await _itemsRepository.GetOneAsync(x => x.Id == tag.ItemId, cancellationToken);
7          
8          if (updateSuccessful && statusUpdate.Status)
9          {
10              var usageHistory = new UsageHistory
11              {
12                  ItemId = tag.ItemId,
13                  Event = "Used",
14                  CreatedDateUtc = DateTime.UtcNow
15              };
16              await _usageHistoryRepository.AddAsync(usageHistory, cancellationToken);
17              
18              await _usageRepository.IncrementTotalCountAsync(tag.ItemId.ToString(), cancellationToken);
19              var totalCount = await _usageService.CalculateTotalBrandUsageByUser(item.BrandId.ToString(), cancellationToken);
20              
21              var brandBonus = await _brandBonusesRepository.GetOneAsync(x => x.BrandId == item.BrandId, cancellationToken);
22              if (brandBonus != null && totalCount > brandBonus.ConditionalNumberOfUsages)
23              {
24                  var currentOffer = await _offersRepository.GetOneAsync(x => x.BrandId == item.BrandId && x.UserId == GlobalUser.Id, cancellationToken);
25                  if (currentOffer != null && currentOffer.Discount < brandBonus.MaxDiscount)
26                  {
27                      currentOffer.Discount += brandBonus.ConditionalDiscount;
28                      await _offersRepository.UpdateAsync(currentOffer, cancellationToken);
29                  }
30                  
31                  brandBonus.ConditionalNumberOfUsages *= brandBonus.ConditionalComplexity;
32                  await _brandBonusesRepository.UpdateAsync(brandBonus, cancellationToken);
33              }
34          }
35  
36          return true;
37      }



     	А.2 Метод для отримання комбінацій, які використовують користувачі


1  public async Task<List<CombinationStatisticsDto>> GetItemCombinationsStatisticsAsync(CancellationToken cancellationToken)
2      {
3          var usageHistory = await _usageHistoryRepository.GetAllAsync(cancellationToken);
4          var items = await _itemsRepository.GetAllAsync(cancellationToken);
5          
6          var groupedByUser = usageHistory
7              .Join(items,
8                  usage => usage.ItemId,
9                  item => item.Id,
10                  (usage, item) => new { Usage = usage, UserId = item.CreatedById })
11              .GroupBy(u => u.UserId);
12      
13          var combinationsStatistics = new List<CombinationStatisticsDto>();
14      
15          foreach (var userGroup in groupedByUser)
16          {
17              var userId = userGroup.Key;
18              var userUsageHistory = userGroup.OrderBy(u => u.Usage.CreatedDateUtc).ToList();
19              
20              for (int i = 0; i < userUsageHistory.Count; i++)
21              {
22                  var currentUsage = userUsageHistory[i];
23                  var currentItemName = await _itemsRepository.GetOneAsync(currentUsage.Usage.ItemId, cancellationToken);
24                  var combination = new List<string> { currentItemName.Name };
25                  
26                  for (int j = i + 1; j < userUsageHistory.Count; j++)
27                  {
28                      var nextUsage = userUsageHistory[j];
29                      
30                      if ((nextUsage.Usage.CreatedDateUtc - currentUsage.Usage.CreatedDateUtc).TotalMinutes <= 5)
31                      {
32                          var itemName = await _itemsRepository.GetOneAsync(nextUsage.Usage.ItemId, cancellationToken);
33                          combination.Add(itemName.Name);
34                      }
35                      else
36                      {
37                          break;
38                      }
39                  }
40                  
41                  if (combination.Count > 1)
42                  {
43                      combinationsStatistics.Add(new CombinationStatisticsDto
44                      {
45                          UserId = userGroup.Key.ToString(),
46                          Combination = combination,
47                          UsageCount = combination.Count
48                      });
49                  }
50              }
51          }
52      
53          return combinationsStatistics;
54      }


     	А.3 Метод для отримання статистики з топом найвикористованіших речей


1  public async Task<List<PopularItemStatisticsDto>> GetTopPopularItemsAsync(string brandId, DateTime startDate, DateTime endDate, int topCount, CancellationToken cancellationToken)
2      {
3          var usageHistory = await _usageHistoryRepository.GetPageAsync(1, topCount, 
4              u => u.CreatedDateUtc >= startDate && u.CreatedDateUtc <= endDate, cancellationToken);
5          
6          var items = await _itemsRepository.GetPageAsync(1, topCount, 
7              x => x.BrandId == ObjectId.Parse(brandId), cancellationToken);
8          
9          var usageForBrandItems = usageHistory.Where(u => items.Any(i => i.Id == u.ItemId));
10          
11          var groupedByItem = usageForBrandItems
12              .GroupBy(u => u.ItemId)
13              .Select(g => new { ItemId = g.Key, UsageCount = g.Count() })
14              .OrderByDescending(x => x.UsageCount)
15              .Take(topCount);
16          
17          var popularItems = new List<PopularItemStatisticsDto>();
18          foreach (var group in groupedByItem)
19          {
20              var itemName = await GetItemNameByIdAsync(group.ItemId, cancellationToken);
21              popularItems.Add(new PopularItemStatisticsDto { ItemName = itemName, UsageCount = group.UsageCount });
22          }
23      
24          return popularItems;
25      }


     	А.4 Метод для отримання статистики по використанню речей за сезон


1  Task<List<SeasonalItemUsageStatisticsDto>> GetSeasonalItemUsageStatisticsAsync(ObjectId brandId, CancellationToken cancellationToken)
2      {
3          var items = await _itemsRepository.GetPageAsync(1, 100, x => x.BrandId == brandId, cancellationToken);
4          
5          var usageHistory = await _usageHistoryRepository.GetPageAsync(1, 100, cancellationToken);
6  
7          var seasonalUsages = new Dictionary<string, Dictionary<string, int>>();
8          foreach (var usage in usageHistory)
9          {
10              var item = items.FirstOrDefault(x => x.Id == usage.ItemId);
11              if (item == null) continue;
12  
13              var season = GetSeason(usage.CreatedDateUtc);
14              if (!seasonalUsages.ContainsKey(season))
15              {
16                  seasonalUsages[season] = new Dictionary<string, int>();
17              }
18  
19              var itemName = item.Name;
20              if (!seasonalUsages[season].ContainsKey(itemName))
21              {
22                  seasonalUsages[season][itemName] = 0;
23              }
24  
25              seasonalUsages[season][itemName]++;
26          }
27  
28          var seasonalStatisticsList = new List<SeasonalItemUsageStatisticsDto>();
29          foreach (var season in seasonalUsages)
30          {
31              var seasonalStatistics = new SeasonalItemUsageStatisticsDto
32              {
33                  Season = season.Key,
34                  TotalUsages = season.Value.Values.Sum(),
35                  ItemUsages = season.Value
36              };
37              seasonalStatisticsList.Add(seasonalStatistics);
38          }
39  
40          return seasonalStatisticsList;
41      }


     	А.5 Створення резервної копії таблиці з бази даних


1  public async Task<IActionResult> ExportToCsv(string collectionName)
2      {
3          var collection = _context.Db.GetCollection<BsonDocument>(collectionName);
4          var data = await collection.Find(new BsonDocument()).ToListAsync();
5  
6          // Create CSV
7          var configuration = new CsvConfiguration(CultureInfo.InvariantCulture)
8          {
9              Delimiter = ",",
10              Encoding = Encoding.UTF8
11          };
12  
13          using (var memoryStream = new MemoryStream())
14          using (var writer = new StreamWriter(memoryStream, Encoding.UTF8))
15          using (var csv = new CsvWriter(writer, configuration))
16          {
17              foreach (var document in data)
18              {
19                  csv.WriteField(document.ToJson());
20                  csv.NextRecord();
21              }
22  
23              writer.Flush();
24              memoryStream.Position = 0;
25  
26              return new FileContentResult(memoryStream.ToArray(), "text/csv")
27              {
28                  FileDownloadName = $"{collectionName}.csv"
29              };
30          }
31      }
















ДОДАТОК Б
Код IoT частини
     	Б.1 Код для визначення руху та відправки результатів на серверну частину


1  import board
2  import busio
3  import digitalio
4  from adafruit_pn532.spi import PN532_SPI
5  import requests
6  import time
7  
8  
9  
10  
11  
12  spi = busio.SPI(board.SCK, board.MOSI, board.MISO)
13  cs_pin = digitalio.DigitalInOut(board.D7)
14  pn532 = PN532_SPI(spi, cs_pin, debug=False)
15  
16  def format_uid(uid):
17      formatted_uid = ""
18      checksum = 0
19      for byte in uid:
20          high_nibble = (byte >> 4) & 0xF
21          low_nibble = byte & 0xF
22          high_char = chr(high_nibble + 48) if high_nibble <         10 else chr(high_nibble + 55)
23          low_char = chr(low_nibble + 48) if low_nibble < 10 else chr(low_nibble + 55)
24          formatted_uid += high_char + low_char
25          checksum += byte
26      checksum_hex = hex(checksum % 256)[2:].zfill(2)
27      formatted_uid += '-' + checksum_hex
28      return formatted_uid
29  
30  pn532.SAM_configuration()
31  
32  print("Waiting for an RFID/NFC card...")
33  while True:
34      uid = pn532.read_passive_target(timeout=0.5)
35      if uid is not None:
36          uid_str = format_uid(uid)
37          print('Found card with UID:', uid_str)
38          try:
39              check_response = requests.get(CHECK_EXIST_URL.format(tagId=uid_str))
40              if check_response.status_code == 200 and check_response.json():
41                  print("Tag already exists. Updating status...")
42                  update_response = requests.put(UPDATE_TAG_URL.format(tagId=uid_str))
43                  if update_response.status_code == 200:
44                      print("Tag status updated successfully.")
45                  else:
46                      print("Failed to update tag status. Status code:", update_response.status_code)
47              else:
48                  print("Tag does not exist. Creating...")
49                  create_response = requests.post(CREATE_TAG_URL, json={"tagId": uid_str})
50                  if create_response.status_code == 200:
51                      print("Tag created successfully.")
52                  else:
53                      print("Failed to create tag. Status code:", create_response.status_code)
54              read_data = pn532.ntag2xx_read_block(4)
55              print("Data read from the tag:", read_data)
56              time.sleep(5)
57          except Exception as e:
58              print("Error:", e)
     	
















ДОДАТОК В
Код клієнтської частини
     В.1 Навігаційна панель


1  /* eslint-disable react-refresh/only-export-components */
2  import { observer } from "mobx-react-lite";
3  import { Button, Container, Menu, Dropdown, DropdownMenu } from "semantic-ui-react";
4  import 'semantic-ui-css/semantic.min.css';
5  import { useEffect } from "react";
6  import { useStore } from "../stores/store";
7  import { Link } from "react-router-dom";
8  import LanguageSelector from "./LanguageSelector";
9  import { useTranslation } from "react-i18next";
10 import { exportToCsv } from "../api/agent";

11 export default observer(function NavBar() {
12    const { userStore: { user, logout, isLoggedIn, getUser } } = useStore();
13    const { t } = useTranslation();

14    useEffect(() => {
15        if (isLoggedIn && !user) {
16            getUser();
17        }
18    }, [isLoggedIn, user, getUser]);

19    const handleLogout = () => {
20        console.log(user);
21        logout();
22        window.location.reload();
23    };

24    const isAdmin = user?.roles?.some(role => role.name === 'Admin');

25    return (
26        <Menu inverted fixed='top'>
27            <Container>
28                <Menu.Item header style={{ position: 'relative' }}>
29                    <div style={{
30                        width: '120px',
31                        height: '120px',
32                        position: 'absolute',
33                        top: '0px',
34                        left: '-150px',
35                        overflow: 'hidden',
36                        backgroundColor: 'white'
37                    }}>
38                        <img src="/assets/logo.png" alt="logo" style={{ width: '100%', height: '100%' }} />
39                    </div>
40                    Wardrobe
41                </Menu.Item>
42                {!isAdmin && (
43                    <>
44                        {user?.roles?.some(role => role.name === 'Business') ? (
45                            <Menu.Item as={Link} to='/brands' name='navbar.myBrands'>
46                                {t('navbar.myBrands')}
47                            </Menu.Item>
48                        ) : (
49                            <>
50                                <Menu.Item as={Link} to='/collections' name='Collections'>
51                                    {t('navbar.collections')}
52                                </Menu.Item>
53                                <Menu.Item>
54                                    <Button positive content={t('navbar.createCollection')} />
55                                </Menu.Item>
56                            </>
57                        )}
58                    </>
59                )}
60                {isAdmin && (
61                    <Menu.Item>
62                        <Button as={Link} to="/admin" content={t('navbar.admin')} />
63                    </Menu.Item>
64                )}

65                {isLoggedIn && user?.roles?.some(role => role.name === 'Admin') && (
66                    <Menu.Item>
67                        <Dropdown text={t('navbar.export')} pointing='top left'>
68                            <Dropdown.Menu>
69                                <Dropdown.Item onClick={() => exportToCsv('Users')}>Users</Dropdown.Item>
70                                <Dropdown.Item onClick={() => exportToCsv('Collections')}>Collections</Dropdown.Item>
71                                <Dropdown.Item onClick={() => exportToCsv('Itmes')}>Itmes</Dropdown.Item>
72                                <Dropdown.Item onClick={() => exportToCsv('Brands')}>Brands</Dropdown.Item>
73                                <Dropdown.Item onClick={() => exportToCsv('RFIDTags')}>RFIDTags</Dropdown.Item>
74                                <Dropdown.Item onClick={() => exportToCsv('BrandBonuses')}>BrandBonuses</Dropdown.Item>
75                                <Dropdown.Item onClick={() => exportToCsv('Usages')}>Usages</Dropdown.Item>
76                                <Dropdown.Item onClick={() => exportToCsv('UsageHistory')}>UsageHistory</Dropdown.Item>
77                            </Dropdown.Menu>
78                        </Dropdown>
79                    </Menu.Item>
80                )}
81                <Menu.Item>
82                    <LanguageSelector />
83                </Menu.Item>

84                {isLoggedIn || user != null ? (
85                    <Menu.Item position='right'>
86                        <Dropdown pointing='top left' text={user?.email}>
87                            <DropdownMenu>
88                                <Dropdown.Item as={Link} to={`/user/profile/${user?.id}`} text={t('navbar.myProfile')} icon='user' />
89                                <Dropdown.Item as={Link} to={`/user/offers`} text={t('navbar.myOffers')} />
90                                {user?.roles?.some(role => role.name === 'Business') && !isAdmin && (
91                                    <>
92                                        <Dropdown.Item>
93                                            <Dropdown text={t('navbar.statistics')}>
94                                                <DropdownMenu>
95                                                    <Dropdown.Item as={Link} to={`/statistics/combo`} text={t('navbar.comboStatistics')} />
96                                                    <Dropdown.Item as={Link} to={`/statistics/top`} text={t('navbar.topStatistics')} />
97                                                    <Dropdown.Item as={Link} to={`/statistics/seasonal`} text={t('navbar.seasonalStatistics')} />
98                                                </DropdownMenu>
99                                            </Dropdown>
100                                       </Dropdown.Item>
101                                       <Dropdown.Item as={Link} to={`/bonus-system`} text={t('navbar.bonusSystem')} />
102                                   </>
103                               )}
104                               <Dropdown.Item onClick={handleLogout} text={t('navbar.logout')} />
105                           </DropdownMenu>
106                       </Dropdown>
107                   </Menu.Item>
108               ) : (
109                   <Menu.Item position='right'>
110                       <Button as={Link} to="/login" content={t('navbar.login')} />
111                       <Button as={Link} to="/register" content={t('navbar.register')} style={{ marginLeft: '0.5em' }} />
112                   </Menu.Item>
113               )}
114           </Container>
115       </Menu>
116   );
117 });


     	В.2 Клас для статистики


1  import { makeAutoObservable, runInAction } from 'mobx';
2  import agent from '../api/agent';

3  export default class StatisticsStore {
4      comboStatistics = [];
5      popularItems = [];
6      seasonalItemUsage = [];
7      loading = false;

8      constructor() {
9          makeAutoObservable(this);
10     }

11     loadComboStatistics = async () => {
12         this.loading = true;
13         try {
14             const stats = await agent.Statistics.getComboStatistics();
15             runInAction(() => {
16                 this.comboStatistics = stats;
17                 this.loading = false;
18             });
19         } catch (error) {
20             console.error("Failed to load combo statistics:", error);
21             runInAction(() => {
22                 this.loading = false;
23             });
24         }
25     };

26     loadPopularItems = async (brandId, startDate, endDate, topCount) => {
27         this.loading = true;
28         try {
29             const stats = await agent.Statistics.getPopularItems(brandId, startDate, endDate, topCount);
30             runInAction(() => {
31                 this.popularItems = stats;
32                 this.loading = false;
33             });
34         } catch (error) {
35             console.error("Failed to load popular items:", error);
36             runInAction(() => {
37                 this.loading = false;
38             });
39         }
40     };

41     loadSeasonalItemUsage = async (brandId) => {
42         this.loading = true;
43         try {
44             const stats = await agent.Statistics.getSeasonalItemUsage(brandId);
45             runInAction(() => {
46                 this.seasonalItemUsage = stats;
47                 this.loading = false;
48             });
49         } catch (error) {
50             console.error("Failed to load seasonal item usage:", error);
51             runInAction(() => {
52                 this.loading = false;
53             });
54         }
55     };
56 }


     	В.3 Компонент для отримання статистики по кількості використань 


1  /* eslint-disable react-refresh/only-export-components */
2  import React, { useEffect, useState } from 'react';
3  import { observer } from 'mobx-react-lite';
4  import { useStore } from '../../app/stores/store';
5  import { Table, Segment, Header, Loader, Dropdown, Form, Button } from 'semantic-ui-react';
6  import DatePicker from 'react-datepicker';
7  import 'react-datepicker/dist/react-datepicker.css';
8  import { format } from 'date-fns';
9  import { PieChart, Pie, Tooltip, Cell, ResponsiveContainer, Legend, BarChart, Bar, XAxis, YAxis } from 'recharts';

10 const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

11 const PopularItemsStatistics = observer(() => {
12     const { statisticsStore, brandStore } = useStore();
13     const { popularItems, loadPopularItems, loading } = statisticsStore;
14     const { brands, loadForUserBrands } = brandStore;

15     const [selectedBrand, setSelectedBrand] = useState('');
16     const [startDate, setStartDate] = useState(null);
17     const [endDate, setEndDate] = useState(null);
18     const [topCount, setTopCount] = useState(5);

19     useEffect(() => {
20         loadForUserBrands();
21     }, [loadForUserBrands]);

22     const handleBrandChange = (e, { value }) => setSelectedBrand(value);
23     const handleStartDateChange = (date) => setStartDate(date);
24     const handleEndDateChange = (date) => setEndDate(date);
25     const handleTopCountChange = (e, { value }) => setTopCount(value);

26     const handleSubmit = () => {
27         if (startDate && endDate) {
28             const formattedStartDate = format(startDate, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
29             const formattedEndDate = format(endDate, "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
30             loadPopularItems(selectedBrand, formattedStartDate, formattedEndDate, topCount);
31         }
32     };

33     if (loading) return <Loader active inline='centered' />;

34     const brandOptions = brands.map(brand => ({ key: brand.id, text: brand.name, value: brand.id }));

35     const chartData = popularItems.map(item => ({
36         name: item.itemName,
37         value: item.usageCount,
38     }));

39     return (
40         <Segment>
41             <Header as='h2'>Popular Items Statistics</Header>
42             <Form onSubmit={handleSubmit}>
43                 <Form.Field>
44                     <label>Select Brand</label>
45                     <Dropdown
46                         placeholder='Select Brand'
47                         fluid
48                         selection
49                         options={brandOptions}
50                         onChange={handleBrandChange}
51                     />
52                 </Form.Field>
53                 <Form.Field>
54                     <label>Select Start Date</label>
55                     <DatePicker
56                         selected={startDate}
57                         onChange={handleStartDateChange}
58                         dateFormat="yyyy-MM-dd"
59                         placeholderText="Start Date"
60                         isClearable
61                         showTimeSelect
62                         timeFormat="HH:mm"
63                         timeIntervals={15}
64                         timeCaption="time"
65                     />
66                 </Form.Field>
67                 <Form.Field>
68                     <label>Select End Date</label>
69                     <DatePicker
70                         selected={endDate}
71                         onChange={handleEndDateChange}
72                         dateFormat="yyyy-MM-dd"
73                         placeholderText="End Date"
74                         isClearable
75                         showTimeSelect
76                         timeFormat="HH:mm"
77                         timeIntervals={15}
78                         timeCaption="time"
79                     />
80                 </Form.Field>
81                 <Form.Field>
82                     <label>Select Top Count</label>
83                     <Dropdown
84                         placeholder='Select Top Count'
85                         fluid
86                         selection
87                         options={[1, 3, 5, 10].map(count => ({ key: count, text: count, value: count }))}
88                         onChange={handleTopCountChange}
89                         defaultValue={5}
90                     />
91                 </Form.Field>
92                 <Button type='submit' positive>Get Statistics</Button>
93             </Form>
94             {popularItems.length === 0 ? (
95                 <Header as='h3' textAlign='center'>No statistics available for the selected criteria</Header>
96             ) : (
97                 <>
98                     <Table celled>
99                         <Table.Header>
100                            <Table.Row>
101                                <Table.HeaderCell>Item Name</Table.HeaderCell>
102                                <Table.HeaderCell>Usage Count</Table.HeaderCell>
103                            </Table.Row>
104                        </Table.Header>
105                        <Table.Body>
106                            {popularItems.map((item, index) => (
107                                <Table.Row key={index}>
108                                    <Table.Cell>{item.itemName}</Table.Cell>
109                                    <Table.Cell>{item.usageCount}</Table.Cell>
110                                </Table.Row>
111                            ))}
112                        </Table.Body>
113                    </Table>
114                    <Header as='h3'>Total Usages by Item (Pie Chart)</Header>
115                    <ResponsiveContainer width="100%" height={400}>
116                        <PieChart>
117                            <Pie
118                                data={chartData}
119                                cx="50%"
120                                cy="50%"
121                                labelLine={false}
122                                label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
123                                outerRadius={150}
124                                fill="#8884d8"
125                                dataKey="value"
126                            >
127                                {chartData.map((entry, index) => (
128                                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
129                                ))}
130                            </Pie>
131                            <Tooltip />
132                            <Legend />
133                        </PieChart>
134                    </ResponsiveContainer>
135                    <Header as='h3'>Total Usages by Item (Bar Chart)</Header>
136                    <ResponsiveContainer width="100%" height={400}>
137                        <BarChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
138                            <XAxis dataKey="name" />
139                            <YAxis />
140                            <Tooltip />
141                            <Legend />
142                            <Bar dataKey="value" fill="#82ca9d" />
143                        </BarChart>
144                    </ResponsiveContainer>
145                </>
146            )}
147        </Segment>
148    );
149 });

150 export default PopularItemsStatistics;




















ДОДАТОК Г
Код мобільного додатка

     	Г.1 Активність для відображення деталей предмета


1    class ItemDetailsActivity : AppCompatActivity() {
2    
3       private lateinit var binding: ActivityItemDetailsBinding
4       private val apiService = ApiServiceImpl()
5       private val tagService = TagServiceImpl()
6       private lateinit var usageAdapter: ItemUsageAdapter
7       private var is24HourFormat: Boolean = true
8    
9       override fun onCreate(savedInstanceState: Bundle?) {
10          super.onCreate(savedInstanceState)
11          binding = ActivityItemDetailsBinding.inflate(layoutInflater)
12          setContentView(binding.root)
13    
14          val itemId = intent.getStringExtra("item_id") ?: return
15          val itemName = intent.getStringExtra("item_name") ?: "Item Details"
16    
17          setSupportActionBar(binding.toolbar)
18          supportActionBar?.setDisplayHomeAsUpEnabled(true)
19          supportActionBar?.title = itemName
20    
21          binding.toolbar.setNavigationOnClickListener {
22              finish()
23          }
24    
25          binding.itemName.text = itemName
26          
27          binding.usageRecyclerView.layoutManager = LinearLayoutManager(this)
28    
29          fetchItemStatistics(itemId)
30          fetchItemUsages(itemId)
31          
32          binding.switchTimeFormat.setOnCheckedChangeListener { _, isChecked ->
33              is24HourFormat = isChecked
34              usageAdapter.set24HourFormat(is24HourFormat)
35          }
36          
37          val bellIcon: ImageView = findViewById(R.id.bell_icon)
38          bellIcon.setOnClickListener {
39              val intent = Intent(this, NotificationsActivity::class.java)
40              intent.putExtra("item_id", itemId)
41              startActivity(intent)
42          }
43          
44          val tagIcon: ImageView = findViewById(R.id.tag_icon)
45          tagIcon.setOnClickListener {
46              val dialog = TagSelectionDialog()
47              dialog.setOnTagSelectedListener { tagId ->
48                  updateItemTag(tagId, itemId)
49              }
50              dialog.show(supportFragmentManager, "TagSelectionDialog")
51          }
52      }
53    
54      private fun fetchItemStatistics(itemId: String) {
55          apiService.getItemStatistics(itemId, 12, object : ApiCallback<List<StatisticDto>> {
56              override fun onSuccess(result: List<StatisticDto>) {
57                  runOnUiThread {
58                      displayItemStatistics(result)
59                  }
60              }
61    
62              override fun onError(error: String) {
63                  Log.e("ItemDetailsActivity", "Failed to fetch item statistics: $error")
64              }
65          })
66      }
67    
68      private fun displayItemStatistics(statistics: List<StatisticDto>) {
69          val chart: PieChart = findViewById(R.id.chart)
70          val entries = mutableListOf<PieEntry>()
71    
72          statistics.forEach {
73              try {
74                  val parts = it.month.split("-")
75                  if (parts.size == 2) {
76                      val monthYear = "${parts[1]}/${parts[0]}"
77                      entries.add(PieEntry(it.usageCount.toFloat(), monthYear))
78                  } else {
79                      Log.e("ItemDetailsActivity", "Invalid month format: ${it.month}")
80                  }
81              } catch (e: Exception) {
82                  Log.e("ItemDetailsActivity", "Error parsing month: ${it.month}", e)
83              }
84          }
85    
86          if (entries.isEmpty()) {
87              Log.e("ItemDetailsActivity", "No valid entries for the chart")
88              return
89          }
90    
91          val dataSet = PieDataSet(entries, "Usage Statistics")
92          dataSet.colors = ColorTemplate.COLORFUL_COLORS.toList() // Set the colors for the chart
93    
94          val pieData = PieData(dataSet)
95          chart.data = pieData
96          chart.invalidate()
97      }
98    
99      private fun fetchItemUsages(itemId: String) {
100         apiService.getItemUsages(itemId, object : ApiCallback<List<UsageDto>> {
101             override fun onSuccess(result: List<UsageDto>) {
102                 runOnUiThread {
103                     displayItemUsages(result)
104                 }
105             }
106    
107             override fun onError(error: String) {
108                 Log.e("ItemDetailsActivity", "Failed to fetch item usages: $error")
109             }
110         })
111     }
112    
113     private fun displayItemUsages(usages: List<UsageDto>) {
114         usageAdapter = ItemUsageAdapter(this, usages, is24HourFormat)
115         binding.usageRecyclerView.adapter = usageAdapter
116     }
117    
118     private fun updateItemTag(tagId: String, itemId: String) {
119         tagService.updateTag(tagId, itemId, object : ApiCallback<Unit> {
120             override fun onSuccess(result: Unit) {
121                 Log.d("ItemDetailsActivity", "Tag updated successfully")
122             }
123    
124             override fun onError(error: String) {
125                 Log.e("ItemDetailsActivity", "Failed to update tag: $error")
126             }
127         })
128     }
129 }
     
      
     	Г.2 Функції для роботи з часовим форматом


1    private fun formatDate(date: String): String {
2        val originalFormat = SimpleDateFormat("dd.MM.yyyy HH:mm:ss", Locale.getDefault())
3        val dateObject = originalFormat.parse(date)
4    
5        return if (is24HourFormat) {
6            val newFormat = SimpleDateFormat("dd.MM.yyyy HH:mm:ss", Locale.getDefault())
7            dateObject?.let { newFormat.format(it) } ?: date
8        } else {
9            val newFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, Locale.US)
10            dateObject?.let { newFormat.format(it) } ?: date
11        }
12    }
13    
14    fun set24HourFormat(is24Hour: Boolean) {
15        is24HourFormat = is24Hour
16        notifyDataSetChanged()
17    }

     	Г.3 Активність для створення резеврацій


1    class ComboStatisticsActivity : AppCompatActivity() {
2    
3        private lateinit var comboStatisticsAdapter: ComboStatisticsAdapter
4        private val statisticsService = StatisticsServiceImpl()
5    
6        override fun onCreate(savedInstanceState: Bundle?) {
7            super.onCreate(savedInstanceState)
8            setContentView(R.layout.activity_combo_statistics)
9    
10           val toolbar = findViewById<Toolbar>(R.id.toolbar)
11           setSupportActionBar(toolbar)
12           supportActionBar?.setDisplayHomeAsUpEnabled(true)
13           supportActionBar?.title = "Combo Statistics"
14    
15           toolbar.setNavigationOnClickListener {
16               val intent = Intent(this, BrandListActivity::class.java)
17               startActivity(intent)
18               finish()
19           }
20    
21           val switchTimeFormat = findViewById<Switch>(R.id.switch_time_format)
22           val statisticsRecyclerView = findViewById<RecyclerView>(R.id.statisticsRecyclerView)
23           statisticsRecyclerView.layoutManager = LinearLayoutManager(this)
24    
25           comboStatisticsAdapter = ComboStatisticsAdapter(this, mutableListOf(), switchTimeFormat.isChecked)
26           statisticsRecyclerView.adapter = comboStatisticsAdapter
27    
28           switchTimeFormat.setOnCheckedChangeListener { _, isChecked ->
29               comboStatisticsAdapter.set24HourFormat(isChecked)
30           }
31    
32           fetchStatistics()
33       }
34    
35       private fun fetchStatistics() {
36           statisticsService.getComboStatistics(object : ApiCallback<List<StatisticComboDto>> {
37               override fun onSuccess(result: List<StatisticComboDto>) {
38                   runOnUiThread {
39                       comboStatisticsAdapter.updateStatistics(result)
40                   }
41               }
42    
43               override fun onError(error: String) {
44                   Log.e("ComboStatisticsActivity", "Failed to fetch statistics: $error")
45               }
46           })
47       }
48   }
ДОДАТОК Д
Діаграми


Рисунок Д.1 – ER модель даних.

Рисунок Д.2 – UML діаграма прецедентів системи.

 
Рисунок Д.3 – UML діаграма діяльності для ІоТ частини.


Рисунок Д.4 – UML діаграма взаємодії у програмному забезпеченні для ІоТ.

2






							119



