1 МЕТА РОБОТИ

Мета роботи полягає в розробці серверної / back-end частини програмної системи та створенні звіту, що містить опис інженерних рішень з посиланнями на програмний код. Під час виконання лабораторної роботи має бути розроблено чотири діаграми, а саме: ER-модель даних, UML діаграма розгортання, UML діаграма прецедентів та UML діаграму діяльності.

2 КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ

Перед розробкою серверної частини, треба чітко описати всі сутності, котрі будуть необхідні для реалізації визначеного функціоналу. Для цього можна розробити ER-модель даних, завдяки якій можна візуалізувати всі сутності та зв’язки між ними. Після визначення всіх необхідних сутностей, була створена ER-модель даних(див. рис. Б.1 у додатку Б).
Модель даних включає в себе наступні сутності та поля для них: а) користувач:
1) користувач_id;
2) ім’я;
3) прізвище;
4) електронна_пошта; 5) ролі;
6) пароль; 7) телефон; 8) місто;
9) країна
б) роль:
1) роль_id;
2) назва;
в) токен_оновлення:
1) токен_id; 2) токен;
3) дата_кінця;
г) пропозиція:
1) пропозиція_id;
2) знижка; д) бренд:
1) бренд_id;
2) назва;
3) оцінка;
е) умови_бонусів_бренду:
1) умови_бонусів_бренду_id;
2) умовна_знижчка;
3) умовна_кількість_використань; 4) умовна_складність;
ж) колекція:
1) колекція_id;
2) назва;
3) опис з) сповіщення:
1) сповіщення_id;
2) умовна_кількість_використань; 3) назва;
4) зміст;
і) історія_використань:
1) історія_використань_id;
2) статус;
3) дата; ї) річ:
1) річ_id;
2) назва;
3) замітки; 4) категорія;


к) всі_використання:
1) всі_використання_id;
2) назва_абонемента;
3) ціна;
4) кількість_відвідувань;
л) RFID_мітка:
1) RFID_мітка_id;
2) статус.
Всі сутності мають поля для правильної реалізації запланованого
функціоналу системи.
Після того, як всі сутності визначені, слід перейти до визначення основних
сценаріїв використання програмної системи. Для цього найкраще зробити UML діаграма прецедентів. Після аналізу функціоналу, котрий був визначений у документі Vision & Scope, була розроблена UML діаграма прецедентів(див. рис. Б.2 у додатку Б), в котрій присутні п’ять акторів, а саме: гість, користувач, бізнес користувач, адміністратор, бізнес адміністратор та ІоТ. Всі актори отримали весь раніше визначений функціонал. Гість може зареєструватися або увійти до системи. Користувач може змінювати особисту інформацію, переглядати створювати та переглядати свої колекції, додавати та видаляти речі з них. Також він має можливість переглянути особисті пропозиції від брендів та статистику його використань.
Бізнес користувач може додавати, редагувати та видаляти інформацію про бренд. Він має змогу формувати статистику по сезонах, топ речей по використанню за обраний час та перегляд комбінацій речей, котрі використовують користувачі.
Адміністратор може змінювати будь-які дані в базі даних та отримувати необхідну інформацію.
В результаті концептуального моделювання предметної області, було розроблено дві діаграми та визначені основні сутності програмної системи. Тепер можна перейти до реалізації інженерних рішень.

3 ІНЖЕНЕРНІ РІШЕННЯ
3.1 Структура та технології проекту

Технології були для написання серверної частини були обрані виходячи з функціональних потреб системи та з особистого досвіду. Тому для написання серверної частини була обрана платформа .NET 8. Специфікація REST орієнтована на використання архітектурного стилю, який підкреслює використання ресурсів та їх ідентифікацію за допомогою URI. В ASP.NET Core були використані контролери, для створення RESTful веб-сервісів, які взаємодіють за принципами архітектурного стилю REST.
В якості бази даних була використана документно-орієнтована база даних MongoDB, оскільки вона надає гнучкість та ефективність у роботі з документами у форматі JSON-подібних об'єктів. MongoDB дозволяє легко масштабувати систему, пристосовуючись до зростання обсягу даних та забезпечуючи швидкий доступ до інформації. Серверна частина взаємодіє з базою даних завдяки Mongo Driver.
Дотаток використовує чисту архітектуру. Суть архітектури полягає в тому, щоб організувати коди таким чином, щоб забезпечити високий рівень абстракції та легкість у тестуванні. Додаток має 5 шарів:
- Шар Domain, в якому зберігаються основні сутності;
- Application інтерфейси, DTOs, маппер профайли;
- Infrastructure включає в себе реалізації сервісів з бізнес логікою:
- Persistence відповідає за доступ до бази даних та містить реалізацію репозиторіїв.
Спілкування між сервером та клієнтською частиною буде реалізоване теж за допомогою REST API. Такий самий тип спілкування застосований і для мобільного додатку, і для IoT. Більш детальніше розглянути взаємодію серверної
частини з іншими елементами системи можна на UML діаграмі розгортання(див. рис. 3.1).
Бізнес адміністратор може створювати резервні копії бази даних у форматі .csv.
Останній актор, це ІоТ пристрій і він може змінювати статус мітки та оновлювати кількість використань. Більш детальніше розглянути взаємодію серверної частини з іншими елементами системи можна на UML діаграмі розгортання(див. рис. 3.1).
Надходження даних від IoT теж буде реалізоване завдяки REST API. Для кращого розуміння взаємодії IoT з серверною частиною, була розроблена UML діаграма діяльності(див. рис. 3.2). Алгоритм має циклічний характер і головна його задача - обчислення RFID міток. Після зчитування, створюється спеціальна модель з інформацією про річ та новий статус, після чого йде відправлення запита на сервер. Після отримання запиту серверною частиною, відбувається перевірка статусу. Якщо статус вказує що річ була використана, то відбувається зміна статусу
мітки в базі даних після чого додається одне використання в історії використання і відбувається збереження змін в базі даних.

3.2 Специфікація REST API

Специфікація REST API наведена в таблиці 1 нижче.

Таблиця 1 – Специфікація REST API серверної частини системи
Сутність
Метод
Посилання
Дія
Користувачі
GET
/users/all
Повернення список користувачів
/users/{id}
Повернення користувача за ідентифікатором
POST
/users/register
Реєстрація користувача
/users/login
Вхід у систему
/users/{id}/roles{role Name}
Додавання ролі користувачу
/users/token/refresh
Оновлення токена доступу для користувача
PUT
/users/update
Оновлення даних користувача
DELETE
/users/{id}/roles{rol eName}
Видалення ролі користувача
/users/{id}
Видалення користувача
Колекція
GET
/collections/all
Повернення всіх колекцій
/collections
Повернення лише видимих колекцій
/collections/{id}
Повернення колекції за її ідентифікатором
POST
/collections/create/
Створення нової колекції
Продовження таблиці 1
Сутність
Метод
Посилання
Дія
Колекція
PUT
/collections/update
Оновлення даних про колекцію
DELETE
/collections/delete/ {id}
Видалення колекції
Річ
GET
/items/all/{collectio nId}
Повертає всі речі колекції
/items/{id}
Повертає річ за ідентифікатором
POST
/items/create
Створює річ
PUT
/items/update
Оновлює дані про річ
DELETE
/items/delete/{id}
Видалення речі
Бренд
GET
/brands/{userId}
Повертає всі бренди, котрі створив користувач
/brand/{id}
Повертає бренд за ідентифікатором.
/brands/all
Повертає всі бренди
POST
/brands/create
Створює бренд
PUT
/brands/update
Оновлює дані про бренд
DELETE
/items/delete/{id}
Видалення бренду             
Продовження таблиці 1
Сутність
Метод
Посилання
Дія
Бонуси бренду
GET
/brandsBonuses/ {brandId}
Отримання бонусів брендів
POST
/brandsBonuses /create
Створює бонуси брендів
PUT
/brandsBonuses/ update
Оновлення даних про бонуси брендів
DELETE
/brandsBonuses/ delete/{id}
Видалення бонуси брендів
Сповіщення
GET
/notifications/{id}
Повертає сповіщення користувача
POST
/notifications/create
Створює сповіщення
PUT
/notifications /update
Оновлює сповіщення
DELETE
/notifications/delete/ {id}
Видалення сповіщення
Пропозиція
GET
/offers/{id}
Повертає пропозиції для користувача
POST
/offers/create
Створює пропозицію для користувача
PUT
/offers/update
Оновлює пропозицію для користувача
DELETE
/offers/delete/{id}
Видалення пропозиції          
Продовження таблиці 1
Сутність
Метод
Посилання
Дія
Використання
GET
/usages/{Id}
Повертає кількість використання предмету, за ідентифікатором
/usages/totalUsageByBrand/{brandId}
Повертає кількість використань певного бренду
POST
/usages/create/ {userId}
Створення даних кількість використань
PUT
/usages/update/ {userId}
Оновлення дпних про кількість використань
DELETE
/usages/delete/{id}
Видалення даних кількість використань
RFID мітка
POST
/rfid/create
Створення нової мітки
PUT
/rfid/updateStatus
Оновлення статусу мітки
Статистика
GET
/statistics/seasonal-it em-usage
Повертає статистику по кількості використань речей за сезони
GET
/statistics/combo
Повертає комбінацію речей, котрі використовує користувач
GET
/statistics/popular-it ems
Повертає топ речей по використанню обраного бренду


3.3 Реалізація методу для обрахування знижки для користувача

Метод UpdateTagAndIncrementUsageAsync виконується при кожному використанні RFID тега, що представляє важливу частину бізнес-логіки системи. Основна мета цього методу - збільшити облік використання товарів і визначити можливість надання знижки користувачу на підставі системи бонусів.
Перш за все, метод виконує оновлення статусу RFID мітки та додає запис у історію використання товарів(див. рядок 10-16, розділ А.1 у додатку А). Це важливо для подальшого аналізу та статистичних обчислень. Далі метод перевіряє, чи був успішно оновлений статус тега і чи відбулось використання. Якщо так, то він збільшує загальний облік використання для конкретного товару. Це інформація може бути використана для аналізу популярності товарів та планування запасів.
Після цього метод розраховує загальну кількість використань бренду користувачем(див. рядок 19, розділ А.1 у додатку А). Ця інформація може бути використана для визначення рівня активності та залучення клієнтів. Далі проводиться аналіз системи бонусів(див. рядок 22-31, розділ А.1 у додатку А). Якщо користувач перевищує умову бонусів для конкретного бренду, система розглядає можливість надання знижки. Це є частиною стратегії залучення та утримання клієнтів. Якщо умови виконані, знижка надається, а параметри бонусів оновлюються для майбутніх обчислень.
Отже, цей метод не лише виконує математичні обчислення для визначення знижок, а й є важливою частиною бізнес-логіки, що сприяє оптимізації процесів та підвищенню задоволеності клієнтів.

3.4 Реалізація методів обробки даних для статистики

Програмна система приділяє дуже багато уваги до статистичних даних, що є невід’ємною частиною бізнес-логіки. Почнемо з статистики, котра виконує аналіз історії використання товарів з метою знаходження комбінацій, які часто використовуються користувачами. Це важлива частина бізнес-логіки, оскільки може допомогти виробникам розуміти популярні комбінації товарів та планувати асортимент. Спочатку метод GetItemCombinationsStatisticsAsync отримує всю історію використання товарів та список всіх товарів з бази даних. Потім він об'єднує ці дані за допомогою ідентифікаторів товарів та користувачів. Після цього метод групує дані за кожним користувачем. Для кожного користувача він сортує його історію використання за датою(див. рядок 6-11, розділ А.2 у додатку А).
Далі метод перебирає історію використання кожного користувача та формує комбінації товарів, які були використані протягом певного періоду часу(див. рядок 26-49, розділ А.2 у додатку А). Кожна комбінація зберігається як список назв товарів. Якщо комбінація містить більше одного товару, вона додається до загального списку статистики комбінацій, який потім повертається як результат методу. Отже, цей метод поєднує в собі аналіз даних, виконує математичні обчислення для знаходження комбінацій товарів та їх частоти використання, а також відображає важливу частину бізнес-логіки, спрямовану на підвищення ефективності та задоволення потреб клієнтів.
Наступний отримує статистику по топ товарів для певного бренду протягом заданого періоду часу. Це важлива частина бізнес-логіки, оскільки допомагає виробникам отримувати інформацію про найпопулярніші продукти та адаптувати свою стратегію виробництва та маркетингу. Спочатку метод отримує історію використання товарів протягом заданого періоду часу. Далі отримує список товарів, що належать до певного бренду(див. рядок 9, розділ А.3 у додатку А). Потім обирає лише ті записи з історії використання, які стосуються товарів з цього бренду. Групує ці дані за ідентифікаторами товарів, рахуючи
кількість використань кожного товару, і сортує в порядку спадання кількості використань. Нарешті, для кожного товару формує об'єкт PopularItemStatisticsDto, який містить назву товару та кількість його використань, і додає його до списку популярних товарів(див. рядок 17-24, розділ А.3 у додатку А). Після цього список повертається як результат методу.
І останній статистичний метод призначений для отримання статистики використання речей за сезон. Це частина бізнес-логіки, оскільки дозволяє виробникам аналізувати, як їхні товари використовуються в різні сезони року, що може впливати на їх стратегію виробництва, маркетингу та постачання. Метод спочатку отримує список товарів, що належать до певного бренду. Потім він отримує всю історію використання товарів за допомогою методу. Далі метод проходиться по кожному запису історії використання і групує їх за сезонами(див. рядок 13-17, розділ А.4 у додатку А), використовуючи допоміжний метод GetSeason, який визначає сезон за датою створення запису. Після цього метод складає статистику для кожного сезону, рахуючи загальну кількість використань кожного товару в межах кожного сезону(див. рядок 29-38, розділ А.4 у додатку А).
Нарешті, результати представлені у вигляді списку об'єктів SeasonalItemUsageStatisticsDto, які містять інформацію про кількість використань кожного товару в кожному сезоні, а також загальну кількість використань за кожний сезон.

3.5 Створення копії даних з таблиці бази даних

Метод ExportToCsv відповідає за експорт даних з вказаної колекції бази даних у формат CSV. Перш ніж створити CSV-файл, він витягує дані з вказаної колекції, використовуючи об'єкт контексту бази даних. Потім він формує
CSV-файл з цими даними, використовуючи бібліотеку CsvHelper(див. рядок 7-29, розділ А.5 у додатку А). У цьому методі немає складної математичної обробки, але він виконує важливу бізнес-логіку, пов'язану з експортом даних, що може бути корисним для аналізу та обробки даних за межами програми. Такий експорт може бути корисним для звітності, обміну даними з іншими системами або для збереження архівних даних.

3.6 Перевірка даних на правильність вводу

Перевірка даних є частиною бізнес логіки, оскільки допомагає забезпечити коректність введених даних та враховує правила домену бізнес-застосування. Якщо введені дані не відповідають встановленим правилам (наприклад, формат електронної пошти або номера телефону), то виникає виключення, що може бути оброблене кодом для відповідного реагування на некоректні дані. Код для перевірки даних наведений нижче:
1 private async void ValidateEmail(string email) 2{
3 string regex = @"^[^@\s]+@[^@\s]+\.[^@\s]+$"; 4
5 if (!Regex.IsMatch(email, regex))
6{
7 throw new InvalidEmailException(email); 8}
9}
10
11 private void ValidatePhone(string phone)
12 {
13 14 15 16
string regex = @"^\+[0-9]{1,15}$";
if (!Regex.IsMatch(phone, regex)) {
17
17 throw new InvalidPhoneNumberException(phone); 18 }
19 }

4 ВИСНОВКИ

В результаті виконання лабораторної роботи, була розроблена та протестована серверна частина програмної системи. Були розроблені діаграми для кращого розуміння предметної області, архітектури системи та взаємодії IoT з серверною частиною. Був записаний відеоролик, де були показані основні функції системи(DEMO: https://www.youtube.com/watch?v=YuhLTteyVrk)
